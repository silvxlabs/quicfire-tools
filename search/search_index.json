{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the quicfire-tools Documentation!","text":""},{"location":"#what-is-quicfire-tools","title":"What is quicfire-tools?","text":"<p>quicfire-tools is a Python package that provides a convenient interface for programmatically creating and managing QUIC-Fire input file decks and processing QUIC-Fire output files into standard Python array data structures.</p> <p>The goals of quicfire-tools are to:</p> <ol> <li>Make it easy to write Python code to work with QUIC-Fire input and output files.</li> <li>Unify code, scripts, and workflows across the QUIC-Fire ecosystem into a single package to support the development of    new QUIC-Fire tools and applications.</li> <li>Provide a platform for collaboration among QUIC-Fire developers and users.</li> </ol>"},{"location":"#what-is-quic-fire","title":"What is QUIC-Fire?","text":"<p>QUIC-Fire is a fast-running, coupled fire-atmospheric modeling tool developed by Los Alamos National Laboratory wildland fire behavior prediction and prescribed fire planning. It combines a 3D wind solver (QUIC-URB) with a physics-based cellular automata fire spread model (Fire-CA) to rapidly simulate the complex interactions between fire, fuels, and atmospheric conditions.</p> <p>Important Licensing Note: QUIC-Fire is a closed-source simulation tool. The maintainers of quicfire-tools are not responsible for QUIC-Fire licensing. Users must obtain QUIC-Fire access through appropriate channels.</p>"},{"location":"#installation","title":"Installation","text":"<p>quicfire-tools can be installed using <code>pip</code> or <code>conda</code>.</p>"},{"location":"#pip","title":"pip","text":"<pre><code>pip install quicfire-tools\n</code></pre>"},{"location":"#conda","title":"conda","text":"<pre><code>conda install conda-forge::quicfire-tools\n</code></pre>"},{"location":"#issues","title":"Issues","text":"<p>If you encounter any issues with the quicfire-tools package, please submit an issue on the quicfire-tools GitHub repository issues page.</p>"},{"location":"explanation/","title":"Explanation","text":""},{"location":"explanation/#inputs-module","title":"Inputs module","text":"<p>The <code>inputs</code> module in <code>quicfire_tools</code> is a central part of the package that handles the creation, modification, and reading of QUIC-Fire input file decks. It provides a programmatic interface to interact with the various input files required for a QUIC-Fire simulation.</p>"},{"location":"explanation/#simulationinputs-class","title":"SimulationInputs Class","text":"<p>The <code>SimulationInputs</code> class is the primary class in the <code>inputs</code> module. It represents a QUIC-Fire input file deck with attributes that represent the state of each input file in the deck. These attributes are instances of various [<code>InputFile</code>] subclasses, each corresponding to a specific input file.</p> <p>The <code>SimulationInputs</code> class provides several methods for creating and modifying simulations. For example, the <code>create_simulation</code> method is used to create a new simulation with default values for fuels, ignitions, and topography. To modify these default values, <code>SimulationInputs</code> offers <code>set_*</code> methods, such as <code>set_uniform_fuels</code> and <code>set_rectangle_ignition</code>, to modify common simulation parameters and maintain consistency across input files.</p> <p>The <code>write_inputs</code> method is also used to write all input files in the <code>SimulationInputs</code> object to a specified directory. This method translates the state stored in the <code>SimulationInputs</code> object into the text format used by QUIC-Fire input files. In addition, simulation state can be saved to a JSON file for sharing, version control, or modification by using the <code>to_json</code> method.</p> <p>The <code>SimulationInputs</code> class also provides methods for reading existing input file decks and converting <code>SimulationInputs</code> objects to and from JSON format. The <code>from_directory</code> method is used to initialize a <code>SimulationInputs</code> object from a directory containing a QUIC-Fire input file deck. The <code>to_json</code> and <code>from_json</code> methods are used to save and load <code>SimulationInputs</code> objects in JSON format.</p>"},{"location":"explanation/#inputfile-class","title":"InputFile Class","text":"<p>Each input file in a QUIC-Fire input file deck has a unique Pydantic Base Model class that represents the state of that input file. These classes are subclasses of the [<code>InputFile</code>] class, which provides common functionality for all input files.</p> <p>This common functionality includes methods for reading and writing input files to disk, as well as methods for converting input files to and from JSON format. The <code>InputFile</code> class also provides methods to output the documentation for a QUIC-Fire parameter in a Python dictionary format.</p>"},{"location":"explanation/#inputfiles-objects-and-pydantic","title":"InputFiles objects and Pydantic","text":"<p>The <code>InputFile</code> class is a subclass of the Pydantic <code>BaseModel</code> class. Pydantic is a Python library that provides data validation and serialization for Python data structures. Pydantic is used in <code>quicfire_tools</code> to validate the state of input files and to serialize input files to and from JSON format.</p> <p>Valid data types, ranges, and defaults are provided for each input file's attributes in the Pydantic <code>BaseModel</code> subclass for that input file. This allows Pydantic to validate the state of input files and raise errors when invalid values are provided.</p>"},{"location":"explanation/#outputs-module","title":"Outputs module","text":"<p>The <code>outputs</code> module in <code>quicfire-tools</code> is responsible for managing and processing simulation outputs produced by QUIC-Fire. It provides efficient ways to access, extract, and organize data from various output files, enabling further analysis and visualization of simulation results.</p>"},{"location":"explanation/#outputfile-class","title":"OutputFile class","text":"<p>The <code>OutputFile</code> class represents a single output variable from a QUIC-Fire simulation. It handles loading the data from disk into NumPy arrays for a given timestep.</p> <p>Key functionality includes:</p> <ul> <li>Mapping compressed formats to dense NumPy arrays</li> <li>Automatically detecting available timesteps</li> <li>Extracting data for specific timesteps</li> <li>Integration with SimulationOutputs class</li> </ul>"},{"location":"explanation/#simulationoutputs-class","title":"SimulationOutputs class","text":"<p>The <code>SimulationOutputs</code> class is the main interface for working with QUIC-Fire output data. It collects available outputs in an Outputs directory and constructs <code>OutputFile</code> instances for each output variable.</p> <p>Key functionality includes:</p> <ul> <li>Detecting available output variables</li> <li>Validating directory structure</li> <li>Getting outputs as NumPy arrays</li> <li>Writing outputs to Zarr files</li> <li>Integration with Dask arrays</li> </ul>"},{"location":"how-to-guides/","title":"How-To Guides","text":""},{"location":"how-to-guides/#inputs","title":"Inputs","text":"<p>QUIC-Fire is controlled by a deck of input files that specify fuel parameters, wind conditions, ignitions, topography, etc. The inputs module provides a simple interface to programatically create and modify new input file decks or read existing decks. The following guides provide step-by-step instructions for working with simple QUIC-Fire input decks. Please see inputs for full documentation.</p>"},{"location":"how-to-guides/#how-to-create-a-basic-quic-fire-simulation","title":"How to create a basic QUIC-Fire simulation","text":"<p>QUIC-Fire input decks are created and modified using the <code>SimulationInputs</code> class.</p> <pre><code>from quicfire_tools.inputs import SimulationInputs\n</code></pre> <p>To create a simulation, use the <code>create_simulation</code> method, and input basic information about the burn domain, initial weather conditions, and simulation parameters. In the following example, we are setting up a simulation that is 200x200 grid cells, with one vertical layer of fuels. The wind is blowing from the east at 1.7 m/s, and the simulation will run for 600 seconds of simulation time.</p> <pre><code>simulation = SimulationInputs.create_simulation(\n    nx=200,\n    ny=200,\n    fire_nz=1,\n    wind_speed=1.7,\n    wind_direction=90,\n    simulation_time=600\n)\n</code></pre> <ul> <li>nx and ny define the number of cells in the x and y axis of the simulation grid.</li> <li>fire_nz determines the number of cells in the z-axis for the fire grid.</li> <li>wind_speed and wind_direction set the initial wind conditions.</li> <li>simulation_time specifies how long the simulation will run in seconds.</li> </ul> <p>This creates a basic input deck with default values for fuels, ignitions, and topography. This simulation can be run as-is, or modified using methods described below.</p>"},{"location":"how-to-guides/#how-to-use-set_-methods-for-common-simulation-parameters","title":"How to use set_* methods for common simulation parameters","text":"<p>Once a simulation is created, it can be modified directly through methods in the <code>SimulationInputs</code> class. For common modifications, convenience methods starting with <code>set_*</code> are available. Guides for all <code>set_*</code> methods are below.</p>"},{"location":"how-to-guides/#how-to-set-uniform-fuel-conditions","title":"How to set uniform fuel conditions","text":"<p>To set and modify fuel parameters for uniform fuels, use the <code>set_uniform_fuels</code> method. In the following example, we are setting surface fuel density to 0.7 kg/m^3, fuel moisture to 5% of its dry weight, and fuel height to 1 meter.</p> <pre><code>simulation.set_uniform_fuels(\n    fuel_density=0.7,\n    fuel_moisture=0.10,\n    fuel_height=1.0\n)\n</code></pre> <ul> <li>fuel_density sets the surface fuel density in kg/m^3.</li> <li>fuel_moisture sets the surface fuel moisture content as a fraction of the fuel's dry weight.</li> <li>fuel_height sets the surface fuel height in meters.</li> </ul>"},{"location":"how-to-guides/#how-to-set-a-rectangle-ignition-pattern","title":"How to set a rectangle ignition pattern","text":"<p>By default, ignitions are set up perpendicular to the wind direction specified in <code>create_simulation</code>, spanning 80% of the domain edge length, 10% from either side. A different igntion line can be created using the <code>set_rectangle_ignition</code> method. In the following example, ignitions start 150m from the western edge of the domain (x=0) and 100m from the southern edge of the domain (y=0). The rectangle extends 10 meters east in the x-direction, and 100m north in the y-direction.</p> <pre><code>simulation.set_rectangle_ignition(\n    x_min=150,\n    y_min=100,\n    x_length=10,\n    y_length=100\n)\n</code></pre> <ul> <li>x_min and y_min set the coordinates of the bottom left corner of the ignition zone. These coordinates are specified in meters, not grid cells.</li> <li>x_length and y_length set the length of the ignition zone in the x and y directions in meters.</li> </ul> <p>Ignition patterns other than rectangular can be specified using the ignitions module. Please see ignitions for a full list of available ignition patterns.</p>"},{"location":"how-to-guides/#how-to-specify-which-files-to-output","title":"How to specify which files to output","text":"<p>Depending on the desired analyses, different files (.bin) may need to be output. To specify with files should be written, use the <code>set_output_files</code> method and set the desired files to true. In the following example, we are specifying outputs for fuel density, various emissions, and wind grid components.</p> <pre><code>simulation.set_output_files(\n    fuel_dens=True,\n    emissions=True,\n    qu_wind_inst=True\n)\n</code></pre> <ul> <li>fuel_dens specifies a compressed array fuel density output.</li> <li>emissions specifies CO, PM2.5, and water emissions outputs.</li> <li>qu_wind_inst specifies gridded wind components (u, v, w) for the QUIC (wind) grid.</li> </ul> <p>By default, an unmodified simulation will output fuel density and QUIC winds. After using <code>set_output_files</code>, all output files not specified as <code>True</code> will be set to false.</p> <p>Please see the <code>QUIC_fire</code> class for a full list of available output files.</p>"},{"location":"how-to-guides/#how-to-set-custom-fuels-ignitions-and-topography-from-dat-files","title":"How to set custom fuels, ignitions, and topography from .dat files","text":"<p>For more advanced simulations, it may be necessary to specify custom fuel parameters, ignition patterns, or topography using .dat files. These files must be created and provided by the user, but the <code>set_custom_simulation</code> method can be used to specify which custom .dat files should be used in the simulation.</p> <pre><code>simulation.set_custom_simulation(\n    fuel_density=True,    # Use treesrhof.dat for fuel density\n    fuel_moisture=True,   # Use treesmoist.dat for fuel moisture\n    fuel_height=True,     # Use treesfueldepth.dat for fuel height\n    size_scale=False,     # Use default size scale\n    patch_and_gap=False,  # Use default patch and gap\n    ignition=True,        # Use ignite.dat for ignition pattern\n    topo=True,            # Use topo.dat for topography\n    interpolate=False     # Don't interpolate custom fuel inputs (default)\n)\n</code></pre> <p>The parameters control which aspects of the simulation will use custom .dat files:</p> <ul> <li>fuel_density: Use treesrhof.dat for fuel density data</li> <li>fuel_moisture: Use treesmoist.dat for fuel moisture data</li> <li>fuel_height: Use treesfueldepth.dat for fuel height data</li> <li>size_scale: Use treesss.dat for size scale data</li> <li>patch_and_gap: Use patch.dat and gap.dat for patch and gap data</li> <li>ignition: Use ignite.dat for ignition pattern</li> <li>topo: Use topo.dat for topography</li> <li>interpolate: Control whether custom fuel inputs are interpolated</li> </ul> <p>Any parameter not set to <code>True</code> will not be specified by a custom .dat file.</p>"},{"location":"how-to-guides/#understanding-the-interpolate-parameter","title":"Understanding the interpolate parameter","text":"<p>The <code>interpolate</code> parameter controls how QUIC-Fire handles the grid spacing of custom fuel inputs. This is particularly important when working with data from sources like FastFuels where the fuel grid spacing may not match the QUIC-Fire grid spacing.</p> <p>When <code>interpolate=False</code> (default): - Sets fuel flags to 3 (for enabled fuel parameters) - Assumes fuel grid spacing matches QUIC-Fire grid spacing - No interpolation is performed - Good for when you know your input data matches the QUIC-Fire grid exactly</p> <p>When <code>interpolate=True</code>: - Sets fuel flags to 4 (for enabled fuel parameters) - Allows fuel grid spacing to differ from QUIC-Fire grid - Interpolates fuel data to match QUIC-Fire grid - May be required for proper functionality in some older versions of QUIC-Fire</p> <p>For example, to properly handle FastFuels data which typically has different grid spacing:</p> <pre><code>simulation.set_custom_simulation(\n    fuel_density=True,\n    fuel_moisture=True,\n    fuel_height=True,\n    interpolate=True\n)\n</code></pre> <p>Note: For versions of QUIC-Fire \u2264 v6.0.0, setting <code>interpolate=True</code> may be required for custom fuels to work properly, regardless of grid spacing.</p>"},{"location":"how-to-guides/#how-to-directly-modify-input-files","title":"How to directly modify input files","text":"<p>Every QUIC-Fire input file is represented in an <code>InputFile</code> class in the inputs module. These classes can be accessed as attributes of the <code>SimulationInputs</code> class, where their parameters can be modified. Some of the more commonly modified input files are below:</p> <ul> <li>QUIC_fire contains parameters relating to the fire simulation, including the fire grid, fuels, ignitions, and output files.</li> <li>QU_TopoInputs contains parameters relating to the underlying topography of the simulation, including topography type and smoothing parameters.</li> <li>Sensor1 contains parameters relating to the wind conditions throughout the simulation.</li> <li>Runtime_Adananced_User_Inputs contains parameters relating to the internal processing of the simulation.</li> </ul>"},{"location":"how-to-guides/#quic_fireinp","title":"QUIC_fire.inp","text":"<p>The <code>QUIC_fire</code> input file class contains many parameters relating to the fire simulation. Once a simulation is created, these parameters can be accessed and modified through <code>SimulationInputs.quic_fire</code>. In the following example, some parameters not accessed by the <code>set_*</code> methods are modified.</p> <pre><code>simulation.quic_fire.random_seed = 47\nsimulation.quic_fire.out_time_fire = 60\nsimulation.quic_fire.ignitions_per_cell = 5\nsimulation.quic_fire.auto_kill = 1\n</code></pre> <p>Please see <code>QUIC_fire</code> for a full list of parameters associated with the QUIC_fire.inp input file.</p>"},{"location":"how-to-guides/#qu_topoinputsinp","title":"QU_TopoInputs.inp","text":"<p>The <code>QU_TopoInputs</code> input file class contains parameters relating to the underlying topography of the simulation. Once a simulation is created, these parameters can be accessed and modified throught <code>QU_TopoInputs</code>. For information on setting custom topography using built-in methods in the topography module, see Set custom topography. In the following example, some parameters not accessed by the <code>set_*</code> methods or the <code>topography</code> module are modified.</p> <pre><code>simulation.qu_topoinputs.smoothing_passes = 500\nsimulation.qu_topoinputs.sor_iteration = 300\n</code></pre> <p>Please see <code>QU_TopoInputs</code> for a full list of parameters associated with the QUIC_fire.inp input file.</p>"},{"location":"how-to-guides/#sensor1inp","title":"sensor1.inp","text":"<p>The 'Sensor1 input file class contains parameters defining wind conditions throughout the simulation. Once a simulation is created, these parameters can be accessed and modified through <code>SimulationInputs.sensor1</code>.</p> <pre><code>simulation.sensor1.sensor_height = 10\n</code></pre> <p>Please see <code>Sensor1</code> for a full list of parameters associated with the sensor1.inp input file.</p>"},{"location":"how-to-guides/#runtime_advanced_user_inputsinp","title":"Runtime_Advanced_User_Inputs.inp","text":"<p>The <code>Runtime_Advanced_User_Inputs</code> input file class condtains two parameters relating to the internal processing of the simulation. Once a simulation is created, these parameters can be accessed and modified throught <code>Runtime_Advanced_User_Inputs</code>. In the following example, the number of CPUs/threads is specifed, along with whether or not to use the adaptive computational window.</p> <pre><code>simulation.runtime_advanced_user_inputs.num_cpus = 1\nsimulation.runtime_advanced_user_inputs.use_acw = 1\n</code></pre>"},{"location":"how-to-guides/#how-to-define-topography-using-topographypy","title":"How to define topography using topography.py","text":"<p>In addition to flat topography (the default) and custom topography, there are various built-in topography types, all of which can be set using classes in the topopgraphy module. The following example creates and sets Gaussian hill topography.</p> <pre><code>from quicfire_tools.topography import GaussianHillTopo\n\n# First, create an TopoType class\ntopo = GaussianHillTopo(\n    x_hilltop=100,\n    y_hilltop=150,\n    elevation_max=50,\n    elevation_std=15\n)\n\n# Next, assign it to the topography attribute of the qu_topoinputs InputFile\nsimulation.qu_topoinputs.topography = topo\n</code></pre> <p>Please see topopgraphy for a full list of topography types.</p>"},{"location":"how-to-guides/#how-to-define-ignitions-using-ignitionspy","title":"How to define ignitions using ignitions.py","text":"<p>In addition to rectangle ignitions (the default) and custom ignitions, there are various build-in ignition patterns, all of which can be set using class in the ignnitions module. The following example creates and sets a circular ring ignition.</p> <pre><code>from quicfire_tools.ignitions import CircularRingIgnition\n\n# First, create an IgnitionType class\nring_ignition = CircularRingIgnition(\n    x_min = 50,\n    y_min = 50,\n    x_length = 20,\n    y_length = 20,\n    ring_width = 10\n)\n\n# Next, assign it to the ignition attribute of the quic_fire InputFile\nsimulation.quic_fire.ignition = ring_ignition\n</code></pre> <p>Please see igntions for a full list of ignition patterns.</p>"},{"location":"how-to-guides/#how-to-manage-wind-conditions","title":"How to manage wind conditions","text":"<p>Wind conditions in QUIC-Fire are managed through wind sensors, which specify wind speeds and directions at specific locations and times. Multiple wind sensors can be used to represent spatial variation in wind conditions across the simulation domain.</p>"},{"location":"how-to-guides/#adding-wind-sensors","title":"Adding wind sensors","text":"<p>The simplest way to add a wind sensor is using the <code>add_wind_sensor</code> method. In the following example, we're creating a sensor with a constant wind speed of 5 m/s blowing from the east:</p> <pre><code>simulation.add_wind_sensor(\n    wind_speeds=5.0,\n    wind_directions=90,\n    wind_times=0\n)\n</code></pre> <p>For varying wind conditions, provide lists of values that change over time. Times are specified in seconds relative to the simulation start (t=0):</p> <pre><code>simulation.add_wind_sensor(\n    wind_speeds=[5.0, 7.0, 6.0],       # Wind speeds in m/s\n    wind_directions=[90, 180, 135],     # Wind directions in degrees\n    wind_times=[0, 600, 1200],         # Changes at 0, 10, and 20 minutes\n    sensor_height=10.0,                 # Sensor height in meters\n    x_location=50.0,                    # X-coordinate in meters\n    y_location=50.0,                    # Y-coordinate in meters\n    sensor_name=\"station_1\"             # Optional custom name\n)\n</code></pre> <ul> <li>wind_speeds specifies wind speeds in meters per second.</li> <li>wind_directions specifies wind directions in degrees (0\u00b0 = North, 90\u00b0 = East).</li> <li>wind_times specifies when each wind condition begins, in seconds from simulation start.</li> <li>sensor_height sets the height of the sensor in meters (defaults to 6.1m/20ft).</li> <li>x_location and y_location set the sensor position in meters.</li> <li>sensor_name provides a custom identifier for the sensor.</li> </ul>"},{"location":"how-to-guides/#adding-wind-sensors-from-data-files","title":"Adding wind sensors from data files","text":"<p>For wind data stored in CSV files or pandas DataFrames, use the <code>add_wind_sensor_from_dataframe</code> method:</p> <pre><code>import pandas as pd\n\n# Read wind data from CSV\nwind_data = pd.read_csv(\"weather_station_data.csv\")\n\nsimulation.add_wind_sensor_from_dataframe(\n    df=wind_data,\n    x_location=100.0,\n    y_location=100.0,\n    sensor_height=6.1,\n    time_column=\"time_seconds\",         # Column containing times\n    speed_column=\"windspeed_ms\",        # Column containing wind speeds\n    direction_column=\"direction_deg\",    # Column containing wind directions\n    sensor_name=\"weather_station_2\"\n)\n</code></pre> <p>The DataFrame must contain columns for: - Times in seconds relative to simulation start - Wind speeds in meters per second - Wind directions in degrees</p>"},{"location":"how-to-guides/#removing-wind-sensors","title":"Removing wind sensors","text":"<p>To remove a wind sensor from the simulation, use the <code>remove_wind_sensor</code> method with the sensor's name:</p> <pre><code>simulation.remove_wind_sensor(\"station_1\")\n</code></pre>"},{"location":"how-to-guides/#notes-on-wind-sensors","title":"Notes on wind sensors","text":"<ul> <li>Multiple wind sensors can be used to represent spatial variation in wind conditions.</li> <li>Wind times must be in ascending order and relative to simulation start (t=0).</li> <li>Wind directions must be in degrees from 0\u00b0 to 360\u00b0.</li> <li>At least one wind sensor must remain in the simulation.</li> <li>The simulation automatically manages wind field update times based on all active sensors.</li> </ul>"},{"location":"how-to-guides/#how-to-read-and-write-input-file-decks","title":"How to read and write input file decks","text":""},{"location":"how-to-guides/#how-to-write-a-simulationinputs-object-to-an-input-deck","title":"How to write a SimulationInputs object to an input deck","text":"<p>Once a <code>SimulationInputs</code> object has been created and modified, it can be used to write all the necessary input files to a directory containing the QUIC-Fire executable. This is done using the <code>write_inputs</code> method.</p> <pre><code>simulation.write_inputs(\"path/to/directory\")\n</code></pre>"},{"location":"how-to-guides/#how-to-load-an-existing-input-deck","title":"How to load an existing input deck","text":"<p>Input decks that already exist may be read in as a <code>SimulationInputs</code> object. The <code>from_directory</code> method is used for this purpose.</p> <pre><code>simulation = SimulationInputs.from_directory(\"path/to/directory\")\n</code></pre>"},{"location":"how-to-guides/#how-to-write-a-simulation-to-json","title":"How to write a simulation to JSON","text":"<p>All the information in a <code>SimulationInputs</code> object may be saved in JSON format using the <code>to_json</code> method.</p> <pre><code>simulation.to_json(\"path/to/directory\")\n</code></pre>"},{"location":"how-to-guides/#how-to-load-a-simulation-from-a-json-file","title":"How to load a simulation from a JSON file","text":"<p>Input decks saved in JSON format by quicfire-tools can be loaded into a <code>SimulationInputs</code> oject using the <code>from_json</code> method.</p> <pre><code>simulation = SimulationInputs.from_json(\"path/to/directory\")\n</code></pre>"},{"location":"how-to-guides/#outputs","title":"Outputs","text":""},{"location":"how-to-guides/#how-to-create-a-simulationoutputs-object-from-a-directory-containing-quic-fire-output-files","title":"How to create a SimulationOutputs object from a directory containing QUIC-Fire output files","text":"<p>To read and process QUIC-Fire output files, use the <code>SimulationOutputs</code> class. You need to specify the path to the directory containing the output files, as well as the number of cells in the z, y, and x directions of the simulation grid.</p> <pre><code>from quicfire_tools.outputs import SimulationOutputs\n\noutput_directory = \"/path/to/output/directory\"\nnz = 56  # number of z cells\nny = 100  # number of y cells\nnx = 100  # number of x cells\n\nsimulation_outputs = SimulationOutputs(output_directory, nz, ny, nx)\n</code></pre>"},{"location":"how-to-guides/#how-to-get-an-outputfile-object-from-a-simulationoutputs-object","title":"How to get an OutputFile object from a SimulationOutputs object","text":"<p>Once you have a <code>SimulationOutputs</code> object, you can use it to get an <code>OutputFile</code> object for a specific output file. To do this, use the <code>get_output_file</code> method of the <code>SimulationOutputs</code> class.</p> <pre><code>from quicfire_tools.outputs import SimulationOutputs\nsimulation_outputs = SimulationOutputs(\"/path/to/output/directory\", 56, 100, 100)\n\noutput_name = \"fire-energy_to_atmos\"  # replace with the name of the output you are interested in\noutput_file = simulation_outputs.get_output(output_name)\n</code></pre>"},{"location":"how-to-guides/#how-to-get-a-numpy-array-from-an-outputfile-object-at-a-specific-timestep","title":"How to get a numpy array from an OutputFile object at a specific timestep","text":"<p>Once you have an <code>OutputFile</code> object, you can use it to get a numpy array for the output data using the <code>to_numpy</code> method of the <code>OutputFile</code> instance. You can specify the timestep(s) you are interested in. If you don't provide a timestep, all timesteps will be returned:</p> <pre><code>from quicfire_tools.outputs import SimulationOutputs\nsimulation_outputs = SimulationOutputs(\"/path/to/output/directory\", 56, 100, 100)\noutput_file = simulation_outputs.get_output(\"fire-energy_to_atmos\")\n\ntimestep = 0  # replace with the timestep you are interested in\noutput_data = output_file.to_numpy(timestep)\n</code></pre>"},{"location":"how-to-guides/#how-to-get-the-data-across-all-timesteps","title":"How to get the data across all timesteps","text":"<p>By not specifying a timestep, you can get the data across all timesteps. This will return a 4D numpy array with the shape (nt, nz, ny, nx), where nt is the number of timesteps.</p> <p>caution: please be aware of the memory requirements your data. This approach may not be appropriate for large simulations or for computers with limited memory.</p> <pre><code>from quicfire_tools.outputs import SimulationOutputs\nsimulation_outputs = SimulationOutputs(\"/path/to/output/directory\", 56, 100, 100)\noutput_file = simulation_outputs.get_output(\"fire-energy_to_atmos\")\n\noutput_data = output_file.to_numpy()\n</code></pre>"},{"location":"how-to-guides/#how-to-get-a-dask-array-from-a-quic-fire-output-file","title":"How to get a dask array from a QUIC-Fire output file","text":"<p>You can use the <code>to_dask</code> method of the <code>SimulationOutputs</code> class to get a dask array for the desired output file. This method returns a <code>dask.array</code> object, which can be used to read and process data in parallel, perform lazy computations, and work with data that is too large to fit in memory.</p> <p>Note that this method returns a dask array, not a numpy array. To get a numpy array, you can use the <code>compute</code> method of the dask array to perform the computations and load data into memory.</p> <p>The dask array returned by this method has the same format as the numpy array returned by the <code>to_numpy</code> method, a 4D array with the shape (nt, nz, ny, nx), where nt is the number of timesteps.</p> <pre><code>from quicfire_tools.outputs import SimulationOutputs\nsimulation_outputs = SimulationOutputs(\"/path/to/output/directory\", 56, 100, 100)\ndask_array = simulation_outputs.to_dask(\"fire-energy_to_atmos\")\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#quicfire_tools.inputs","title":"quicfire_tools.inputs","text":"<p>QUIC-Fire Tools Simulation Input Module</p>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs","title":"SimulationInputs","text":"<p>Class representing a QUIC-Fire input file deck. This class is the primary interface for building a QUIC-Fire input file deck and saving the input files to a directory for running a simulation.</p> <p>Attributes:</p> Name Type Description <code>rasterorigin</code> <code>RasterOrigin</code> <p>Object representing the rasterorigin.txt file.</p> <code>qu_buildings</code> <code>QU_Buildings</code> <p>Object representing the QU_buildings.inp file.</p> <code>qu_fileoptions</code> <code>QU_Fileoptions</code> <p>Object representing the QU_fileoptions.inp file.</p> <code>qfire_advanced_user_inputs</code> <code>QFire_Advanced_User_Inputs</code> <p>Object representing the qfire_advanced_user_inputs.inp file.</p> <code>qfire_bldg_advanced_user_inputs</code> <code>QFire_Bldg_Advanced_User_Inputs</code> <p>Object representing the qfire_bldg_advanced_user_inputs.inp file.</p> <code>qfire_plume_advanced_user_inputs</code> <code>QFire_Plume_Advanced_User_Inputs</code> <p>Object representing the qfire_plume_advanced_user_inputs.inp file.</p> <code>runtime_advanced_user_inputs</code> <code>RuntimeAdvancedUserInputs</code> <p>Object representing the runtime_advanced_user_inputs.inp file.</p> <code>qu_movingcoords</code> <code>QU_movingcoords</code> <p>Object representing the QU_movingcoords.inp file.</p> <code>qp_buildout</code> <code>QP_buildout</code> <p>Object representing the qp_buildout.inp file.</p> <code>quic_fire</code> <code>QUIC_fire</code> <p>Object representing the QUIC_fire.inp file.</p> <code>wind_sensors</code> <code>dict[str, WindSensor]</code> <p>Object representing the all wind sensor input files, e.g. sensor1.inp.</p> <code>qu_topoinputs</code> <code>QU_TopoInputs</code> <p>Object representing the QU_topoinputs.inp file.</p> <code>qu_simparams</code> <code>QU_Simparams</code> <p>Object representing the QU_simparams.inp file.</p>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.create_simulation","title":"create_simulation  <code>classmethod</code>","text":"<pre><code>create_simulation(\n    nx: int,\n    ny: int,\n    fire_nz: int,\n    wind_speed: float,\n    wind_direction: int,\n    simulation_time: int,\n) -&gt; SimulationInputs\n</code></pre> <p>Creates a SimulationInputs object by taking in the mimum required information to build a QUIC-Fire input file deck. Returns a SimulationInputs object representing the complete state of the QUIC-Fire simulation.</p> <p>Parameters:</p> Name Type Description Default <code>nx</code> <code>int</code> <p>Number of cells in the x-direction [-]. Default cell size is 2m.</p> required <code>ny</code> <code>int</code> <p>Number of cells in the y-direction [-]. Default cell size is 2m.</p> required <code>fire_nz</code> <code>int</code> <p>Number of cells in the z-direction for the fire grid [-]. Default cell size is 1m.</p> required <code>wind_speed</code> <code>float</code> <p>Wind speed [m/s].</p> required <code>wind_direction</code> <code>int</code> <p>Wind direction [deg]. 0 deg is north, 90 deg is east, etc. Must be in range [0, 360).</p> required <code>simulation_time</code> <code>int</code> <p>Number of seconds to run the simulation for [s].</p> required <p>Returns:</p> Type Description <code>SimulationInputs</code> <p>Class containing the data to build a QUIC-Fire input file deck and run a simulation using default parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.from_directory","title":"from_directory  <code>classmethod</code>","text":"<pre><code>from_directory(\n    directory: str | Path, version: str = \"latest\"\n) -&gt; SimulationInputs\n</code></pre> <p>Initializes a SimulationInputs object from a directory containing a QUIC-Fire input file deck. The function looks for each input file in the QUIC-Fire input file deck, reads in the file to an object, and compiles the objects to a SimulationInputs object that represents the complete state of the QUIC-Fire simulation.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Directory containing a QUIC-Fire input file deck.</p> required <code>version</code> <code>str</code> <p>QUIC-Fire version of the input files to read. Currently supported versions are \"v5\", \"v6\", and \"latest\". Default is \"latest\".</p> <code>'latest'</code> <p>Returns:</p> Type Description <code>SimulationInputs</code> <p>Class containing the input files in the QUIC-Fire input file deck.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; simulation_path = \"path/to/simulation/directory\"\n&gt;&gt;&gt; sim_inputs = SimulationInputs.from_directory(simulation_path)\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; SimulationInputs\n</code></pre> <p>Initializes a SimulationInputs object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing input file data.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; json_path = \"path/to/json/object\"\n&gt;&gt;&gt; sim_inputs = SimulationInputs.from_json(json_path)\n&gt;&gt;&gt; sim_dict = sim_inputs.to_dict()\n&gt;&gt;&gt; new_sim_inputs = SimulationInputs.from_dict(sim_dict)\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(path: str | Path) -&gt; SimulationInputs\n</code></pre> <p>Initializes a SimulationInputs object from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the JSON file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; json_path = \"path/to/json/object\"\n&gt;&gt;&gt; sim_inputs = SimulationInputs.from_json(json_path)\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.write_inputs","title":"write_inputs","text":"<pre><code>write_inputs(\n    directory: str | Path, version: str = \"latest\"\n) -&gt; None\n</code></pre> <p>Write all input files in the SimulationInputs object to a specified directory.</p> <p>This method is a core method of the SimulationInputs class. It is the principle way to translate a SimulationInputs object into a QUIC-Fire input file deck.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Directory to write the input files to.</p> required <code>version</code> <code>str</code> <p>Version of the input files to write. Default is \"latest\".</p> <code>'latest'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_inputs.write_inputs(\"path/to/simulation/directory\")\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the state of the SimulationInputs object to a dictionary. The name of each input file in the SimulationInputs object is a key to that input file's dictionary form.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_dict = sim_inputs.to_dict()\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path) -&gt; None\n</code></pre> <p>Write the SimulationInputs object to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to write the JSON file to.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_inputs.to_json(\"path/to/json/object\")\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.set_custom_simulation","title":"set_custom_simulation","text":"<pre><code>set_custom_simulation(\n    fuel_density: bool = True,\n    fuel_moisture: bool = True,\n    fuel_height: bool = True,\n    size_scale: bool = False,\n    patch_and_gap: bool = False,\n    ignition: bool = True,\n    topo: bool = True,\n    interpolate: bool = False,\n) -&gt; None\n</code></pre> <p>Sets the simulation to use custom fuel, ignition, and topography settings.</p> <p>This function can be useful for setting up simulations that use .dat files to define custom fuel, topography, or ignition inputs.</p> <p>Parameters:</p> Name Type Description Default <code>fuel_density</code> <code>bool</code> <p>If True, sets the simulation to use fuel density information from a treesrhof.dat file (fuel density flag 3). Default is True.</p> <code>True</code> <code>fuel_moisture</code> <code>bool</code> <p>If True, sets the simulation to use fuel moisture information from a treesmoist.dat file (fuel moisture flag 3). Default is True.</p> <code>True</code> <code>fuel_height</code> <code>bool</code> <p>If True, sets the simulation to use fuel height information from a treesdepth.dat file (fuel height flag 3). Default is True.</p> <code>True</code> <code>size_scale</code> <code>bool</code> <p>If True, sets the simulation to use size scale information from a treesss.dat file (size scale flag 3). Defaults to False as this is a new feature.</p> <code>False</code> <code>patch_and_gap</code> <code>bool</code> <p>If True, sets the simulation to use patch and gap information from patch.dat and gap.dat files (patch and gap flag 2). Defaults to False as this is a new feature.</p> <code>False</code> <code>ignition</code> <code>bool</code> <p>If True, sets the simulation to use a custom ignition source (ignition flag 6). Default is True.</p> <code>True</code> <code>topo</code> <code>bool</code> <p>If True, sets the simulation to use custom topography settings (topography flag 5). Default is True.</p> <code>True</code> <code>interpolate</code> <code>bool</code> <p>If True, sets the simulation to interpolate the custom fuel inputs to the fire grid (fuel flag 4). Default is False. This is also useful as it addresses a bug in versions of QUIC-Fire \u2264 v6.0.0 where custom fuels don't work without the interpolation flag set. Interpolation only applies to fuel density, fuel moisture, fuel height, and size scale. Patch and gap, ignition, and topography are not interpolated.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_inputs.set_custom_simulation(fuel=True, ignition=True, topo=True)\n&gt;&gt;&gt; sim_inputs.quic_fire.fuel_flag\n3\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.set_uniform_fuels","title":"set_uniform_fuels","text":"<pre><code>set_uniform_fuels(\n    fuel_density: float,\n    fuel_moisture: float,\n    fuel_height: float,\n    size_scale: float = 0.0005,\n    patch_size: float = 0.0,\n    gap_size: float = 0.0,\n) -&gt; None\n</code></pre> <p>Sets the simulation to use uniform fuel settings. This function updates the fuel flag to 1 and sets the fuel density, fuel moisture, and fuel height to the specified values.</p> <p>Parameters:</p> Name Type Description Default <code>fuel_density</code> <code>float</code> <p>Fuel bulk density [kg/m^3]. Note: This is the fuel bulk density, so the fuel load should be normalized by the height of the fuel bed.</p> required <code>fuel_moisture</code> <code>float</code> <p>Fuel moisture content [%].</p> required <code>fuel_height</code> <code>float</code> <p>Fuel bed height [m].</p> required <code>size_scale</code> <code>float</code> <p>Size scale [m]. Default is 0.0005.</p> <code>0.0005</code> <code>patch_size</code> <code>float</code> <p>Patch size [m]. Default is 0.0.</p> <code>0.0</code> <code>gap_size</code> <code>float</code> <p>Gap size [m]. Default is 0.0.</p> <code>0.0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_inputs.set_uniform_fuels(fuel_density=0.5, fuel_moisture=25, fuel_height=1)\n&gt;&gt;&gt; sim_inputs.quic_fire.fuel_density_flag\n1\n&gt;&gt;&gt; sim_inputs.quic_fire.fuel_density\n0.5\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.set_rectangle_ignition","title":"set_rectangle_ignition","text":"<pre><code>set_rectangle_ignition(\n    x_min: float,\n    y_min: float,\n    x_length: float,\n    y_length: float,\n) -&gt; None\n</code></pre> <p>Sets the simulation to use a rectangle ignition source. This function updates the ignition flag to 1 and sets the ignition source to the specified rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>South-west corner in the x-direction [m]</p> required <code>y_min</code> <code>float</code> <p>South-west corner in the y-direction [m]</p> required <code>x_length</code> <code>float</code> <p>Length in the x-direction [m]</p> required <code>y_length</code> <code>float</code> <p>Length in the y-direction [m]</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_inputs.set_rectangle_ignition(x_min=0, y_min=0, x_length=10, y_length=10)\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.set_output_files","title":"set_output_files","text":"<pre><code>set_output_files(\n    eng_to_atm: bool = False,\n    react_rate: bool = False,\n    fuel_dens: bool = False,\n    qf_wind: bool = False,\n    qu_wind_inst: bool = False,\n    qu_wind_avg: bool = False,\n    fuel_moist: bool = False,\n    mass_burnt: bool = False,\n    emissions: bool = False,\n    radiation: bool = False,\n    surf_eng: bool = False,\n) -&gt; None\n</code></pre> <p>Sets the simulation to output the specified files. Files set to True will be output by the simulation, and files set to False will not be output.</p> <p>Parameters:</p> Name Type Description Default <code>eng_to_atm</code> <code>bool</code> <p>If True, output the fire-energy_to_atmos.bin file. Default is False.</p> <code>False</code> <code>react_rate</code> <code>bool</code> <p>If True, output the fire-reaction_rate.bin file. Default is False.</p> <code>False</code> <code>fuel_dens</code> <code>bool</code> <p>If True, output the fuels-dens.bin file. Default is False.</p> <code>False</code> <code>qf_wind</code> <code>bool</code> <p>If True, output the windu, windv, and windw .bin files. Default is False.</p> <code>False</code> <code>qu_wind_inst</code> <code>bool</code> <p>If True, output the quic_wind_inst.bin file. Default is False.</p> <code>False</code> <code>qu_wind_avg</code> <code>bool</code> <p>If True, output the quic_wind_avg.bin file. Default is False.</p> <code>False</code> <code>fuel_moist</code> <code>bool</code> <p>If True, output the fuels-moist.bin file. Default is False.</p> <code>False</code> <code>mass_burnt</code> <code>bool</code> <p>If True, output the mburnt_integ.bin file. Default is False.</p> <code>False</code> <code>emissions</code> <code>bool</code> <p>If True, output the co-emissions and pm-emissions .bin files. Default is False.</p> <code>False</code> <code>radiation</code> <code>bool</code> <p>If True, output the thermaldose and thermalradiation .bin files. Default is False.</p> <code>False</code> <code>surf_eng</code> <code>bool</code> <p>If True, output the surf_eng.bin file. Default is False.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_inputs.set_output_files(fuel_dens=True, mass_burnt=True)\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.set_output_interval","title":"set_output_interval","text":"<pre><code>set_output_interval(interval: int)\n</code></pre> <p>Sets the interval, in seconds, at which the simulation will write .bin files to disk. This function sets the same interval for all output files.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Interval in seconds at which to write .bin files to disk.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from quicfire_tools import SimulationInputs\n&gt;&gt;&gt; sim_inputs = SimulationInputs.create_simulation(nx=100, ny=100, fire_nz=26, wind_speed=1.8, wind_direction=90, simulation_time=600)\n&gt;&gt;&gt; sim_inputs.set_output_interval(60)\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.add_wind_sensor","title":"add_wind_sensor","text":"<pre><code>add_wind_sensor(\n    wind_speeds: Union[float, List[float]],\n    wind_directions: Union[int, List[int]],\n    wind_times: Union[int, List[int]],\n    sensor_height: float = 6.1,\n    x_location: float = 1.0,\n    y_location: float = 1.0,\n    sensor_name: str = None,\n    wind_update_frequency: int = 300,\n) -&gt; None\n</code></pre> <p>Adds a new wind sensor to the simulation with specified wind conditions. This method handles the coordination between multiple QUIC-Fire input files that contain wind information and ensures they stay synchronized.</p> <p>Parameters:</p> Name Type Description Default <code>wind_speeds</code> <code>float or List[float]</code> <p>Wind speed(s) in meters per second. Can be a single value for constant wind or a list of values for varying wind conditions.</p> required <code>wind_directions</code> <code>int or List[int]</code> <p>Wind direction(s) in degrees, where 0\u00b0 is North and degrees increase clockwise (90\u00b0 is East). Can be a single value or a list matching wind_speeds.</p> required <code>wind_times</code> <code>int or List[int]</code> <p>Time(s) in seconds relative to simulation start (t=0) when each wind condition begins. For constant wind, use 0. For varying winds, provide a list of times corresponding to each speed/direction pair (e.g., [0, 600, 1200] for changes at 0, 10, and 20 minutes).</p> required <code>sensor_height</code> <code>float</code> <p>Height of the sensor in meters. Defaults to 6.1m (20 feet), which is standard weather station height.</p> <code>6.1</code> <code>x_location</code> <code>float</code> <p>X-coordinate position of the sensor in meters. Defaults to 1.0.</p> <code>1.0</code> <code>y_location</code> <code>float</code> <p>Y-coordinate position of the sensor in meters. Defaults to 1.0.</p> <code>1.0</code> <code>sensor_name</code> <code>str</code> <p>Custom name for the sensor. If not provided, will be automatically generated as \"sensorN\" where N is the next available number.</p> <code>None</code> <code>wind_update_frequency</code> <code>int</code> <p>Minimum time in seconds between wind field updates. Defaults to 300 seconds (5 minutes). Smaller values increase computation time but may improve accuracy.</p> <code>300</code> <p>Examples:</p> <p>Adding a sensor with constant wind:</p> <pre><code>&gt;&gt;&gt; sim_inputs.add_wind_sensor(\n...     wind_speeds=5.0,\n...     wind_directions=90,\n...     wind_times=0\n... )\n</code></pre> <p>Adding a sensor with varying wind conditions starting at t=0 and changing every 10 minutes:</p> <pre><code>&gt;&gt;&gt; sim_inputs.add_wind_sensor(\n...     wind_speeds=[5.0, 7.0, 6.0],\n...     wind_directions=[90, 180, 135],\n...     wind_times=[0, 600, 1200],  # Changes at 0, 10, and 20 minutes\n...     sensor_height=10.0,\n...     x_location=50.0,\n...     y_location=50.0,\n...     sensor_name=\"custom_sensor\"\n... )\n</code></pre> Notes <ul> <li>Wind times must be provided relative to simulation start (t=0), not as absolute times.</li> <li>Wind lists must have equal lengths and correspond to each other (i.e., wind_times[0]   corresponds to wind_speeds[0] and wind_directions[0]).</li> <li>Wind times must be in ascending order.</li> <li>Wind directions must be in degrees from 0 to 360.</li> <li>Multiple sensors can be added to the same simulation to represent spatial variation   in wind conditions.</li> </ul>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.add_wind_sensor_from_dataframe","title":"add_wind_sensor_from_dataframe","text":"<pre><code>add_wind_sensor_from_dataframe(\n    df: DataFrame,\n    x_location: float,\n    y_location: float,\n    sensor_height: float,\n    time_column: str = \"wind_times\",\n    speed_column: str = \"wind_speeds\",\n    direction_column: str = \"wind_directions\",\n    sensor_name: Optional[str] = None,\n    wind_update_frequency: int = 300,\n) -&gt; None\n</code></pre> <p>Adds a wind sensor to the simulation using wind data from a pandas DataFrame. This is particularly useful when importing wind data from CSV files or other tabular data sources.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame containing wind data. Must include columns for times, speeds, and directions (column names can be specified using the column parameters).</p> required <code>x_location</code> <code>float</code> <p>X-coordinate position of the sensor in meters.</p> required <code>y_location</code> <code>float</code> <p>Y-coordinate position of the sensor in meters.</p> required <code>sensor_height</code> <code>float</code> <p>Height of the sensor in meters (typically 6.1m/20ft for standard weather stations).</p> required <code>time_column</code> <code>str</code> <p>Name of the DataFrame column containing wind times in seconds relative to simulation start (t=0). Defaults to \"wind_times\".</p> <code>'wind_times'</code> <code>speed_column</code> <code>str</code> <p>Name of the DataFrame column containing wind speeds in meters per second. Defaults to \"wind_speeds\".</p> <code>'wind_speeds'</code> <code>direction_column</code> <code>str</code> <p>Name of the DataFrame column containing wind directions in degrees (0\u00b0 = North, 90\u00b0 = East). Defaults to \"wind_directions\".</p> <code>'wind_directions'</code> <code>sensor_name</code> <code>str</code> <p>Custom name for the sensor. If not provided, will be automatically generated as \"sensorN\" where N is the next available number.</p> <code>None</code> <code>wind_update_frequency</code> <code>int</code> <p>Minimum time in seconds between wind field updates. Defaults to 300 seconds (5 minutes).</p> <code>300</code> <p>Examples:</p> <p>Using default column names:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; wind_data = pd.DataFrame({\n...     'wind_times': [0, 600, 1200],      # Times at 0, 10, and 20 minutes\n...     'wind_speeds': [5.0, 7.0, 6.0],    # Wind speeds in m/s\n...     'wind_directions': [90, 180, 135]   # Wind directions in degrees\n... })\n&gt;&gt;&gt; sim_inputs.add_wind_sensor_from_dataframe(\n...     df=wind_data,\n...     x_location=50.0,\n...     y_location=50.0,\n...     sensor_height=6.1\n... )\n</code></pre> <p>Using custom column names:</p> <pre><code>&gt;&gt;&gt; weather_data = pd.DataFrame({\n...     'time_s': [0, 300, 600],           # Times in seconds from start\n...     'speed_ms': [4.0, 5.0, 4.5],       # Speeds in m/s\n...     'direction_deg': [45, 90, 75]      # Directions in degrees\n... })\n&gt;&gt;&gt; sim_inputs.add_wind_sensor_from_dataframe(\n...     df=weather_data,\n...     x_location=100.0,\n...     y_location=100.0,\n...     sensor_height=10.0,\n...     time_column='time_s',\n...     speed_column='speed_ms',\n...     direction_column='direction_deg',\n...     sensor_name='weather_station_1'\n... )\n</code></pre> Notes <ul> <li>Wind times in the DataFrame must be relative to simulation start (t=0), not absolute times.</li> <li>Times must be in ascending order.</li> <li>Wind directions must be in degrees from 0 to 360.</li> <li>All columns must contain numeric data in the correct units (seconds, m/s, degrees).</li> <li>Multiple sensors can be added to represent spatial variation in wind conditions.</li> </ul> See Also <p>add_wind_sensor : Add a wind sensor using direct parameter inputs</p>"},{"location":"reference/#quicfire_tools.inputs.SimulationInputs.remove_wind_sensor","title":"remove_wind_sensor","text":"<pre><code>remove_wind_sensor(\n    sensor_name: str, wind_update_frequency: int = 300\n) -&gt; None\n</code></pre> <p>Removes a wind sensor from the simulation by its name and updates the simulation's wind timing parameters accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>Name of the wind sensor to remove. Must match exactly the name of an existing sensor in the simulation.</p> required <code>wind_update_frequency</code> <code>int</code> <p>Minimum time in seconds between wind field updates after sensor removal. Defaults to 300 seconds (5 minutes). This parameter is used to recalculate wind update times for remaining sensors.</p> <code>300</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified sensor_name is not found in the simulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Add two wind sensors\n&gt;&gt;&gt; sim_inputs.add_wind_sensor(\n...     wind_speeds=5.0,\n...     wind_directions=90,\n...     wind_times=0,\n...     sensor_name=\"sensor1\"\n... )\n&gt;&gt;&gt; sim_inputs.add_wind_sensor(\n...     wind_speeds=6.0,\n...     wind_directions=180,\n...     wind_times=0,\n...     sensor_name=\"sensor2\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Remove the first sensor\n&gt;&gt;&gt; sim_inputs.remove_wind_sensor(\"sensor1\")\n</code></pre> Notes <ul> <li>After removing a sensor, the simulation's wind update times are automatically   recalculated based on the remaining sensors.</li> <li>Make sure at least one wind sensor remains in the simulation for valid results.</li> <li>Sensor names are case-sensitive.</li> </ul> See Also <p>add_wind_sensor : Add a wind sensor using direct parameter inputs add_wind_sensor_from_dataframe : Add a wind sensor using data from a DataFrame</p>"},{"location":"reference/#quicfire_tools.inputs.InputFile","title":"InputFile","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class representing an input file.</p> <p>This base class provides a common interface for all input files in order to accomplish two main goals:</p> <p>1) Return documentation for each parameter in the input file.</p> <p>2) Provide a method to write the input file to a directory.</p>"},{"location":"reference/#quicfire_tools.inputs.InputFile.list_parameters","title":"list_parameters","text":"<pre><code>list_parameters() -&gt; list[str]\n</code></pre> <p>Get a list of the names of all parameters in the input file.</p>"},{"location":"reference/#quicfire_tools.inputs.InputFile.get_documentation","title":"get_documentation","text":"<pre><code>get_documentation(parameter: str = None) -&gt; dict\n</code></pre> <p>Retrieve documentation for a parameter. If no parameter is specified, return documentation for all parameters.</p>"},{"location":"reference/#quicfire_tools.inputs.InputFile.print_documentation_table","title":"print_documentation_table","text":"<pre><code>print_documentation_table(parameter: str = None) -&gt; None\n</code></pre> <p>Print documentation for a parameter. If no parameter is specified, print documentation for all parameters.</p>"},{"location":"reference/#quicfire_tools.inputs.InputFile.to_dict","title":"to_dict","text":"<pre><code>to_dict(include_private: bool = False) -&gt; dict\n</code></pre> <p>Convert the object to a dictionary, excluding attributes that start with an underscore.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object.</p>"},{"location":"reference/#quicfire_tools.inputs.InputFile.to_file","title":"to_file","text":"<pre><code>to_file(directory: Path, version: str = 'latest')\n</code></pre> <p>Write the input file to a specified directory.</p> <p>Attributes:</p> Name Type Description <code>directory</code> <code>Path</code> <p>Directory to write the input file to.</p> <code>version</code> <code>str</code> <p>Version of the input file to write. Default is \"latest\".</p>"},{"location":"reference/#quicfire_tools.inputs.Gridlist","title":"Gridlist","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the gridlist.txt file. This file contains the grid information for the QUIC-Fire simulation when canopies are present.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>Number of cells in the x-direction [-]</p> <code>m</code> <code>int</code> <p>Number of cells in the y-direction [-]</p> <code>l</code> <code>int</code> <p>Number of cells in the z-direction [-]</p> <code>dx</code> <code>float</code> <p>Cell size in the x-direction [m]</p> <code>dy</code> <code>float</code> <p>Cell size in the y-direction [m]</p> <code>dz</code> <code>float</code> <p>Cell size in the z-direction [m]</p> <code>aa1</code> <code>float</code> <p>Stretching factor for the vertical grid spacing [-]</p>"},{"location":"reference/#quicfire_tools.inputs.Gridlist.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a Gridlist object from a directory containing a gridlist.txt file.</p>"},{"location":"reference/#quicfire_tools.inputs.RasterOrigin","title":"RasterOrigin","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the rasterorigin.txt file. This file contains the coordinates of the south-west corner of the domain in UTM coordinates.</p> <p>Attributes:</p> Name Type Description <code>utm_x</code> <code>float</code> <p>UTM-x coordinates of the south-west corner of domain [m]</p> <code>utm_y</code> <code>float</code> <p>UTM-y coordinates of the south-west corner of domain [m]</p>"},{"location":"reference/#quicfire_tools.inputs.RasterOrigin.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a RasterOrigin object from a directory containing a rasterorigin.txt file.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_Buildings","title":"QU_Buildings","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QU_buildings.inp file. This file contains the building-related data for the QUIC-Fire simulation. This class is not currently used in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>wall_roughness_length</code> <code>float</code> <p>Wall roughness length [m]. Must be greater than 0. Default is 0.1.</p> <code>number_of_buildings</code> <code>int</code> <p>Number of buildings [-]. Default is 0. Not currently used in QUIC-Fire.</p> <code>number_of_polygon_nodes</code> <code>int</code> <p>Number of polygon building nodes [-]. Default is 0. Not currently used in QUIC-Fire.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_Buildings.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a QU_Buildings object from a directory containing a QU_buildings.inp file.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_Fileoptions","title":"QU_Fileoptions","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QU_fileoptions.inp file. This file contains file output-related options for the QUIC-Fire simulation.</p> <p>Attributes:</p> Name Type Description <code>output_data_file_format_flag</code> <code>int</code> <p>Output data file format flag. Values accepted are [1, 2, 3]. Recommended value 2. 1 - binary, 2 - ASCII, 3 - both.</p> <code>non_mass_conserved_initial_field_flag</code> <code>int</code> <p>Flag to write out non-mass conserved initial field file uofield.dat. Values accepted are [0, 1]. Recommended value 0. 0 - off, 1 - on.</p> <code>initial_sensor_velocity_field_flag</code> <code>int</code> <p>Flag to write out the file uosensorfield.dat. Values accepted are [0, 1]. Recommended value 0. 0 - off, 1 - on.</p> <code>qu_staggered_velocity_file_flag</code> <code>int</code> <p>Flag to write out the file QU_staggered_velocity.bin. Values accepted are [0, 1]. Recommended value 0. 0 - off, 1 - on.</p> <code>generate_wind_startup_files_flag</code> <code>int</code> <p>Generate wind startup files for ensemble simulations. Values accepted are [0, 1]. Recommended value 0. 0 - off, 1 - on.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_Fileoptions.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a QU_Fileoptions object from a directory containing a QU_fileoptions.inp file.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_Simparams","title":"QU_Simparams","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QU_simparams.inp file. This file contains the simulation parameters for the QUIC-Fire simulation.</p> <p>Attributes:</p> Name Type Description <code>nx</code> <code>int</code> <p>Number of cells in the x-direction [-]. Recommended value: &gt; 100</p> <code>ny</code> <code>int</code> <p>Number of cells in the y-direction [-]. Recommended value: &gt; 100</p> <code>nz</code> <code>int</code> <p>Number of cells in the z-direction [-].</p> <code>dx</code> <code>float</code> <p>Cell size in the x-direction [m]. Recommended value: 2 m</p> <code>dy</code> <code>float</code> <p>Cell size in the y-direction [m]. Recommended value: 2 m</p> <code>quic_domain_height</code> <code>float</code> <p>QUIC domain height [m]. Recommended value: 300 m</p> <code>surface_vertical_cell_size</code> <code>float</code> <p>Surface vertical cell size [m].</p> <code>number_surface_cells</code> <code>int</code> <p>Number of uniform surface cells [-].</p> <code>stretch_grid_flag</code> <code>int</code> <p>Vertical grid stretching flag, values accepted [0, 1, 3]. Default is 3. 0 - uniform, 1 - custom, 3 - parabolic. If stretch_grid_flag is 0 or 3 dz_array is computed from nz, surface_vertical_cell_size, and number_surface_cells. If stretch_grid_flag is 1, custom_dz_array must be provided.</p> <code>custom_dz_array</code> <code>list[float]</code> <p>Vertical grid spacing array [m]. Must be provided if stretch_grid_flag is 1. If stretch_grid_flag is 0 or 3, dz_array is computed from nz, surface_vertical_cell_size, and number_surface_cells.</p> <code>utc_offset</code> <code>int</code> <p>Hours difference from UTC (aka UTM) [h]</p> <code>wind_times</code> <code>list[int]</code> <p>List of times at which the winds are available in Unix Epoch time (integer seconds since 1970/1/1 00:00:00). These are UTC times. Defaults to [int(time.time())] if not provided.</p> <code>sor_iter_max</code> <code>int</code> <p>Maximum number of iterations of the SOR wind solver. Recommended value: 10. Default is 10.</p> <code>sor_residual_reduction</code> <code>int</code> <p>Residual reduction to assess convergence of the SOR solver (orders of magnitude). Recommended value: 3. Default is 3.</p> <code>use_diffusion_flag</code> <code>int</code> <p>Use diffusion algorithm: 0 = off, 1 = on. Recommended value: 0. Default is 0.</p> <code>number_diffusion_iterations</code> <code>int</code> <p>Number of diffusion iterations. Recommended value: 10. Default is 10.</p> <code>domain_rotation</code> <code>float</code> <p>Domain rotation relative to true north (clockwise is positive) [degrees]. Recommended value: 0 deg. Default is 0.</p> <code>utm_x</code> <code>float</code> <p>UTM-x coordinates of the south-west corner of domain [m]. Default is 0.</p> <code>utm_y</code> <code>float</code> <p>UTM-y coordinates of the south-west corner of domain [m]. Default is 0.</p> <code>utm_zone_number</code> <code>int</code> <p>UTM zone number [-]. Default is 1.</p> <code>utm_zone_letter</code> <code>int</code> <p>UTM zone letter (A=1, B=2, ...) [-]. Default is 1.</p> <code>quic_cfd_flag</code> <code>int</code> <p>QUIC-CFD flag: 0 = off, 1 = on. Recommended value: 0. Default is 0.</p> <code>explosive_bldg_flag</code> <code>int</code> <p>Explosive building damage flag: 0 = off, 1 = on. Recommended value: 0. Default is 0.</p> <code>bldg_array_flag</code> <code>int</code> <p>Building array flag. 0 = off, 1 = on. Recommended value: 0. Default is 0.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_Simparams.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a QU_Simparams object from a directory containing a QU_simparams.inp file.</p>"},{"location":"reference/#quicfire_tools.inputs.QFire_Advanced_User_Inputs","title":"QFire_Advanced_User_Inputs","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QFire_Advanced_User_Inputs.inp input file. This file contains advanced parameters related to firebrands.</p> <p>Attributes:</p> Name Type Description <code>fraction_cells_launch_firebrands</code> <code>PositiveFloat</code> <p>Fraction of cells that could launch firebrand tracers from which firebrand tracers will actually be launched [-]. Higher value = more firebrand tracers. Recommended value: 0.05</p> <code>firebrand_radius_scale_factor</code> <code>PositiveFloat</code> <p>Multiplicative factor used to relate the length scale of the mixing (firebrand distribution entrainment length scale) to the initial size of the distribution [-]. Higher value = higher growth rate or RT (firebrand distribution) with flight time. Recommended value: 40</p> <code>firebrand_trajectory_time_step</code> <code>PositiveInt</code> <p>Time step used to determine the firebrand tracer trajectory [s]. Higher value = less accurate trajectory. Recommended value: 1 s</p> <code>firebrand_launch_interval</code> <code>PositiveInt</code> <p>Time interval between launching of firebrand tracers [s]. Higher value = less firebrand tracers launched. Recommended value: 10 s</p> <code>firebrands_per_deposition</code> <code>PositiveInt</code> <p>Number of firebrand tracers that one firebrand tracer launched represents [-]. Recommended value: 500</p> <code>firebrand_area_ratio</code> <code>PositiveFloat</code> <p>Multiplicative factor used to relate the cell area and fraction of cells from which tracers are launched to initial area represented by one firebrand [-].</p> <code>minimum_burn_rate_coefficient</code> <code>PositiveFloat</code> <p>Multiplicative factor relating the minimum mass-loss rate that a firebrand tracer needs to have to justify continuing to track its trajectory to the energy associated with a new ignition [-].</p> <code>max_firebrand_thickness_fraction</code> <code>PositiveFloat</code> <p>Multiplicative factor relating the thickness of launched firebrand tracer to maximum loftable firebrand thickness [-].</p> <code>firebrand_germination_delay</code> <code>PositiveInt</code> <p>Time after a firebrand has landed at which a fire is started [s]</p> <code>vertical_velocity_scale_factor</code> <code>PositiveFloat</code> <p>Maximum value of the multiplicative factor of the vertical velocity experienced by a firebrand = 1/(fraction of the QUIC-URB on fire) [-]</p> <code>minimum_firebrand_ignitions</code> <code>PositiveInt</code> <p>Minimum number of ignitions to be sampled in a position where a firebrand lands [-]</p> <code>maximum_firebrand_ignitions</code> <code>PositiveInt</code> <p>Maximum number of ignitions sampled at positions distributed within RT around where a firebrand tracer lands [-]</p> <code>minimum_landing_angle</code> <code>PositiveFloat</code> <p>Minimum value considered for the angle between the trajectory of the firebrand when it hits the ground and horizontal [rad]</p> <code>maximum_firebrand_thickness</code> <code>PositiveFloat</code> <p>Maximum firebrand's thickness [m]</p>"},{"location":"reference/#quicfire_tools.inputs.QFire_Advanced_User_Inputs.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a QFire_Advanced_User_Inputs object from a directory containing a QFire_Advanced_User_Inputs.inp file.</p>"},{"location":"reference/#quicfire_tools.inputs.QUIC_fire","title":"QUIC_fire","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QUIC_fire.inp input file. This file contains the parameters relating to the fire simulation and outputs.</p> <p>Attributes:</p> Name Type Description <code>fire_flag</code> <code>Literal[0, 1]</code> <p>Fire flag, 1 = run fire; 0 = no fire</p> <code>random_seed</code> <code>int</code> <p>Random number generator, -1: use time and date, any other integer &gt; 0</p> <code>time_now</code> <code>PositiveInt</code> <p>When the fire is ignited in Unix Epoch time (integer seconds since 1970/1/1 00:00:00). Must be greater or equal to the time of the first wind</p> <code>sim_time</code> <code>PositiveInt</code> <p>Total simulation time for the fire [s]</p> <code>fire_time_step</code> <code>PositiveInt</code> <p>Time step for the fire simulation [s]</p> <code>quic_time_step</code> <code>PositiveInt</code> <p>Number of fire time steps done before updating the quic wind field (integer, &gt;= 1)</p> <code>out_time_fire</code> <code>PositiveInt</code> <p>After how many fire time steps to print out fire-related files (excluding emissions and radiation)</p> <code>out_time_wind</code> <code>PositiveInt</code> <p>After how many quic updates to print out wind-related files</p> <code>out_time_emis_rad</code> <code>PositiveInt</code> <p>After how many fire time steps to average emissions and radiation</p> <code>out_time_wind_avg</code> <code>PositiveInt</code> <p>After how many quic updates to print out averaged wind-related files</p> <code>nz</code> <code>PositiveInt</code> <p>Number of fire grid cells in the z-direction.</p> <code>stretch_grid_flag</code> <code>Literal[0, 1]</code> <p>Vertical stretching flag: 0 = uniform dz, 1 = custom</p> <code>dz</code> <code>PositiveFloat</code> <p>Cell size in the z-direction [m] of the fire grid. Recommended value: 1m</p> <code>dz_array</code> <code>List[PositiveFloat]</code> <p>Custom dz, one dz per line must be specified, from the ground to the top of the domain</p> <code>fuel_density_flag</code> <code>Literal[1, 2, 3, 4, 5]</code> <p>Fuel density flag (defaults to 1): 1 = density is uniform over the domain, 2 = density is provided through QF_FuelDensity.inp, 3 = density is provided through Firetec file (treesrhof.dat) matching QUIC-Fire grid, 4 = density is provided through Firetec files for an arbitrary grid, 5 = FastFuels input (assuming uniform dz of 1m)</p> <code>fuel_density</code> <code>PositiveFloat</code> <p>Fuel density (kg/m3)</p> <code>fuel_moisture_flag</code> <code>Literal[1, 2, 3, 4, 5]</code> <p>Fuel moisture flag (defaults to 1): 1 = moisture is uniform over the domain, 2 = moisture is provided through QF_FuelMoisture.inp, 3 = moisture is provided through Firetec file (treesmoist.dat) matching QUIC-Fire grid, 4 = moisture is provided through Firetec files for an arbitrary grid, 5 = FastFuels input (assuming uniform dz of 1m)</p> <code>fuel_moisture</code> <code>PositiveFloat</code> <p>Fuel moisture = mass of water/mass of dry fuel (kg/kg). Must be between 0 and 1.</p> <code>fuel_height_flag</code> <code>Literal[1, 2, 3, 4]</code> <p>Fuel height flag (defaults to 1): 1 = height is uniform over the domain, 2 = height is provided through QF_FuelHeight.inp, 3 = height is provided through Firetec file (treesheight.dat) matching QUIC-Fire grid, 4 = height is provided through Firetec files for an arbitrary grid, 5 = FastFuels input (assuming uniform dz of 1m)</p> <code>fuel_height</code> <code>PositiveFloat</code> <p>Fuel height of surface layer (m)</p> <code>size_scale_flag</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>Size scale flag (defaults to 0): 0 = Default value (0.0005) over entire domain, 1 = custom uniform value over the domain, 2 = custom value provided through QF_SizeScale.inp, 3 = custom value provided through Firetec file (treesss.dat) matching QUIC-Fire grid, 4 = custom value provided through Firetec files for an arbitrary grid, 5 = FastFuels input (assuming uniform dz of 1m)</p> <code>size_scale</code> <code>PositiveFloat</code> <p>Size scale (m). Defaults to 0.0005.</p> <code>patch_and_gap_flag</code> <code>Literal[0, 1, 2]</code> <p>Patch and gap flag (defaults to 0): 0 = Default values (0, 0) over entire domain, 1 = custom uniform values over the domain, 2 = custom values provided by patch.dat and gap.dat</p> <code>ignition</code> <code>Ignition</code> <p>Ignition type specified as an IgnitionsType class from ignitions.py 1 = rectangle 2 = square ring 3 = circular ring 6 = ignite.dat (Firetec file)</p> <code>ignitions_per_cell</code> <code>PositiveInt</code> <p>Number of ignition per cell of the fire model. Recommended max value of 100</p> <code>firebrand_flag</code> <code>Literal[0, 1]</code> <p>Firebrand flag, 0 = off; 1 = on. Recommended value = 0; firebrands are untested for small scale problems</p> <code>auto_kill</code> <code>Literal[0, 1]</code> <p>Kill if the fire is out and there are no more ignitions or firebrands (0 = no, 1 = yes)</p> <code>eng_to_atm_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: gridded energy-to-atmosphere (3D fire grid + extra layers)</p> <code>react_rate_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: compressed array reaction rate (fire grid)</p> <code>fuel_dens_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: compressed array fuel density (fire grid)</p> <code>qf_wind_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: gridded wind (u,v,w,sigma) (3D fire grid)</p> <code>qu_wind_inst_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: gridded QU winds with fire effects, instantaneous (QUIC-URB grid)</p> <code>qu_wind_avg_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: gridded QU winds with fire effects, averaged (QUIC-URB grid)</p> <code>fuel_moist_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: compressed array fuel moisture (fire grid)</p> <code>mass_burnt_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: vertically-integrated % mass burnt (fire grid)</p> <code>firebrand_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: firebrand trajectories. Must be 0 when firebrand flag is 0</p> <code>emissions_out</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>Output flag [0, 5]: compressed array emissions (fire grid):     0 = do not output any emission related variables     1 = output emissions files and simulate CO in QUIC-SMOKE     2 = output emissions files and simulate PM2.5 in QUIC- SMOKE     3 = output emissions files and simulate both CO and PM2.5 in         QUIC-SMOKE     4 = output emissions files but use library approach in QUIC-SMOKE     5 = output emissions files and simulate both water in QUIC-SMOKE</p> <code>radiation_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: gridded thermal radiation (fire grid)</p> <code>surf_eng_out</code> <code>Literal[0, 1]</code> <p>Output flag [0, 1]: surface fire intensity at every fire time step</p>"},{"location":"reference/#quicfire_tools.inputs.QUIC_fire.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a QUIC_fire object from a directory containing a QUIC_Fire.inp file.</p>"},{"location":"reference/#quicfire_tools.inputs.QFire_Bldg_Advanced_User_Inputs","title":"QFire_Bldg_Advanced_User_Inputs","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QFire_Bldg_Advanced_User_Inputs.inp input file. This file contains advanced parameters related to buildings and fuel.</p> <p>Attributes:</p> Name Type Description <code>convert_buildings_to_fuel_flag</code> <code>int</code> <p>Flag to convert QUIC-URB buildings to fuel. 0 = do not convert, 1 = convert. Recommended value: 0.</p> <code>building_fuel_density</code> <code>PositiveFloat</code> <p>Thin fuel density within buildings if no fuel is specified and buildings are converted to fuel. Higher value = more fuel. Recommended value: 0.5. Units: [kg/m^3]</p> <code>building_attenuation_coefficient</code> <code>PositiveFloat</code> <p>Attenuation coefficient within buildings if buildings are converted to fuel. Higher value = more drag. Recommended value: 2.</p> <code>building_surface_roughness</code> <code>PositiveFloat</code> <p>Surface roughness within buildings if buildings are converted to fuel. Higher value = lower wind speed. Recommended value: 0.01 m. Units: [m]</p> <code>convert_fuel_to_canopy_flag</code> <code>int</code> <p>Flag to convert fuel to canopy for winds. 0 = do not convert, 1 = convert. Recommended value: 1.</p> <code>update_canopy_winds_flag</code> <code>int</code> <p>Flag to update canopy winds when fuel is consumed. 0 = do not update, 1 = update. Recommended value: 1.</p> <code>fuel_attenuation_coefficient</code> <code>PositiveFloat</code> <p>Attenuation coefficient within fuel for the wind profile. Higher value = more drag. Recommended value: 1.</p> <code>fuel_surface_roughness</code> <code>PositiveFloat</code> <p>Surface roughness within fuel. Higher value = lower wind speed. Recommended value: 0.1 m. Units: [m]</p>"},{"location":"reference/#quicfire_tools.inputs.QFire_Bldg_Advanced_User_Inputs.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a QFire_Bldg_Advanced_User_Inputs object from a directory containing a QFire_Bldg_Advanced_User_Inputs.inp file.</p>"},{"location":"reference/#quicfire_tools.inputs.QFire_Plume_Advanced_User_Inputs","title":"QFire_Plume_Advanced_User_Inputs","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QFire_Plume_Advanced_User_Inputs.inp input file. This file contains advanced parameters related to modeling buoyant plumes.</p> <p>Attributes:</p> Name Type Description <code>max_plumes_per_timestep</code> <code>PositiveInt</code> <p>Maximum number of plumes allowed at each time step. Higher values slow down the simulation. Default value: 150,000. Recommended range: 50,000 - 500,000.</p> <code>min_plume_updraft_velocity</code> <code>PositiveFloat</code> <p>Minimum plume updraft velocity [m/s]. If plume velocity drops below this value, the plume is removed. Higher values reduce number of plumes. Default value: 0.1 m/s.</p> <code>max_plume_updraft_velocity</code> <code>PositiveFloat</code> <p>Maximum allowed plume updraft velocity [m/s]. Default value: 100 m/s.</p> <code>min_velocity_ratio</code> <code>PositiveFloat</code> <p>Minimum ratio between plume updraft velocity and wind speed. If ratio drops below this value, plume is removed. Higher values reduce plumes. Default value: 0.1.</p> <code>brunt_vaisala_freq_squared</code> <code>NonNegativeFloat</code> <p>Inverse of the Brunt-Vaisala frequency squared [1/s^2], a measure of atmospheric stability. Default value: 0 1/s^2.</p> <code>creeping_flag</code> <code>Literal[0, 1]</code> <p>Flag to enable (1) or disable (0) fire spread by creeping. Default value: 1.</p> <code>adaptive_timestep_flag</code> <code>Literal[0, 1]</code> <p>Enable (1) or disable (0) adaptive time stepping. Adaptive time stepping improves accuracy but increases simulation time. Default value: 0.</p> <code>plume_timestep</code> <code>PositiveFloat</code> <p>Time step [s] used to compute buoyant plume trajectories. Higher values reduce accuracy. Default value: 1s.</p> <code>sor_option_flag</code> <code>Literal[0, 1]</code> <p>SOR solver option. 0 = standard SOR, 1 = memory SOR. Default value: 1.</p> <code>sor_alpha_plume_center</code> <code>PositiveFloat</code> <p>SOR alpha value at plume centerline. Higher values reduce influence of plumes on winds. Default value: 10.</p> <code>sor_alpha_plume_edge</code> <code>PositiveFloat</code> <p>SOR alpha value at plume edge. Higher values reduce influence of plumes on winds. Default value: 1. max_plume_merging_angle : PositiveFloat Maximum angle [degrees] between plumes to determine merging eligibility. Higher values increase plume merging. Default value: 30 degrees.</p> <code>max_plume_overlap_fraction</code> <code>PositiveFloat</code> <p>Maximum fraction of smaller plume trajectory overlapped by larger plume to be considered for merging. Higher values increase merging.</p> <code>plume_to_grid_updrafts_flag</code> <code>Literal[0, 1]</code> <p>Method to map plume updrafts to grid. 0 = new method, 1 = old method. New method improves accuracy. Default value: 1. New method takes longer, but is needed if smoke is simulated afterwards.</p> <code>max_points_along_plume_edge</code> <code>PositiveInt</code> <p>Maximum points to sample along grid cell edge for new plume-to-grid method. Default value: 10.</p> <code>plume_to_grid_intersection_flag</code> <code>Literal[0, 1]</code> <p>Scheme to sum plume-to-grid updrafts when multiple plumes intersect a grid cell. 0 = cube method, 1 = max value method. Default value: 1.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_TopoInputs","title":"QU_TopoInputs","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QU_TopoInputs.inp input file. This file contains advanced data pertaining to topography.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>Path to the custom topo file (only used with option 5). Cannot be .bin. Use .dat or .inp</p> <code>topography</code> <code>Topography</code> <p>Topography type specified as a TopoType class from topography.py 0 = no terrain file provided, QUIC-Fire is run with flat terrain 1 = Gaussian hill 2 = hill pass 3 = slope mesa 4 = canyon 5 = custom 6 = half circle 7 = sinusoid 8 = cos hill 9 = terrain is provided via QP_elevation.bin (see Section 2.7) 10 = terrain is provided via terrainOutput.txt 11 = terrain.dat (firetec)</p> <code>smoothing_method</code> <code>Literal[0, 1, 2]</code> <p>0 = none (default for idealized topo) 1 = Blur 2 = David Robinson\u2019s method based on second derivative</p> <code>smoothing_passes</code> <code>NonNegativeInt</code> <p>Number of smoothing passes. Real terrain MUST be smoothed</p> <code>sor_iterations</code> <code>PositiveInt</code> <p>Number of SOR iteration to define background winds before starting the fire</p> <code>sor_cycles</code> <code>Literal[0, 1, 2, 3, 4]</code> <p>Number of times the SOR solver initial fields is reset to define background winds before starting the fire</p> <code>sor_relax</code> <code>PositiveFloat</code> <p>SOR overrelaxation coefficient. Only used if there is topo.</p>"},{"location":"reference/#quicfire_tools.inputs.RuntimeAdvancedUserInputs","title":"RuntimeAdvancedUserInputs","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the Runtime_Advanced_User_Inputs.inp input file. This file contains advanced parameters related to computer memory usage.</p> <p>Attributes:</p> Name Type Description <code>num_cpus</code> <code>PositiveInt</code> <p>Maximum number of CPU to use. Do not exceed 8. Use 1 for ensemble simulations. Defaults to 1.</p> <code>use_acw</code> <code>Literal[0, 1]</code> <p>Use Adaptive Computation Window (0=Disabled 1=Enabled). Defaults to 0.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_movingcoords","title":"QU_movingcoords","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QU_movingcoords.inp input file. This is a QUIC legacy file that is not modified for QUIC-Fire use.</p>"},{"location":"reference/#quicfire_tools.inputs.QP_buildout","title":"QP_buildout","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QU_buildout.inp input file. This is a QUIC legacy file that is not modified for QUIC-Fire use.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_metparams","title":"QU_metparams","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing the QU_metparams.inp input file. This file contains information about wind profiles.</p> <p>Attributes:</p> Name Type Description <code>site_names</code> <code>list[str]</code> <p>List of site names. Must be the same length as file_names.</p> <code>file_names</code> <code>list[str]</code> <p>List of file names. Must be the same length as site_names.</p>"},{"location":"reference/#quicfire_tools.inputs.QU_metparams.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, **kwargs)\n</code></pre> <p>Initializes a QU_metparams object from a directory containing a QU_metparams.inp file.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Directory containing the QU_metparams.inp file</p> required <p>Returns:</p> Type Description <code>QU_metparams</code> <p>Initialized QU_metparams object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be parsed correctly</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensor","title":"WindSensor","text":"<p>               Bases: <code>InputFile</code></p> <p>Class representing a sensor.inp input file. This file contains information on winds, and serves as the primary source for wind speed(s) and direction(s). Multiple sensor.inp files may be created.</p> <p>Attributes:</p> Name Type Description <code>wind_times</code> <code>NonNegativeFloat | list(NonNegativeFloat)</code> <p>Time in seconds since the start of the fire for each wind shift.</p> <code>wind_speeds</code> <code>PositiveFloat | list(PositiveFloat)</code> <p>Wind speed or list of wind speeds (m/s)</p> <code>wind_directions</code> <code>NonNegativeInt &lt; 360 | list(NonNegativeInt &lt; 360)</code> <p>Wind direction or list of directions (degrees). Use 0\u00b0 for North</p> <code>sensor_heights</code> <code>PositiveFloat | list(PositiveFloat)</code> <p>Wind measurement height (m). Default is 6.1m (20ft). If a scalar is provided, it will be used for all wind_times.</p> <code>x_location</code> <code>PositiveInt</code> <p>Location of the sensor in the x-direction</p> <code>y_location</code> <code>PositiveInt</code> <p>Location of the sensor in the y-direction</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensor.validate_wind_inputs","title":"validate_wind_inputs","text":"<pre><code>validate_wind_inputs()\n</code></pre> <p>Validate wind inputs: 1. Ensure wind_times, wind_speeds, and wind_directions are lists. 2. Ensure all wind-related lists have equal lengths.</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensor.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path, sensor_name: str)\n</code></pre> <p>Initializes a WindSensor object from a directory containing a sensor .inp file.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Directory containing the sensor .inp file.</p> required <code>sensor_name</code> <code>str</code> <p>Name of the sensor to read. A \".inp\" string is appended to the name to get the file name.</p> required <p>Returns:</p> Type Description <code>WindSensor</code> <p>Initialized WindSensor object.</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensor.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(\n    df: DataFrame,\n    name: str,\n    x_location: float,\n    y_location: float,\n    sensor_height: float,\n    time_column_name: str = \"wind_times\",\n    speed_column_name: str = \"wind_speeds\",\n    direction_column_name: str = \"wind_directions\",\n) -&gt; \"WindSensor\"\n</code></pre> <p>Creates a WindSensor object from a pandas DataFrame containing wind data.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Pandas DataFrame containing wind data with columns for times, speeds, and directions.</p> required <code>name</code> <code>str</code> <p>Name to assign to the sensor.</p> required <code>x_location</code> <code>float</code> <p>Location of the wind sensor in the x-direction in meters</p> required <code>y_location</code> <code>float</code> <p>Location of the wind sensor in the y-direction in meters</p> required <code>sensor_height</code> <code>float</code> <p>Height of the wind sensor in meters</p> required <code>time_column_name</code> <code>str</code> <p>Name of column containing wind times. Defaults to \"wind_times\"</p> <code>'wind_times'</code> <code>speed_column_name</code> <code>str</code> <p>Name of column containing wind speeds. Defaults to \"wind_speeds\"</p> <code>'wind_speeds'</code> <code>direction_column_name</code> <code>str</code> <p>Name of column containing wind directions. Defaults to \"wind_directions\"</p> <code>'wind_directions'</code> <p>Returns:</p> Type Description <code>WindSensor</code> <p>Initialized WindSensor object with data from the DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; winds_df = pd.read_csv(\"winds.csv\")\n&gt;&gt;&gt; sensor = WindSensor.from_dataframe(\n...     df, sensor_name=\"sensor_csv\", x_location=50, y_location=50, sensor_height=6.1\n... )\n</code></pre>"},{"location":"reference/#quicfire_tools.inputs.WindSensorArray","title":"WindSensorArray","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class containing all WindSensor input files and shared attributes.</p> <p>Attributes:</p> Name Type Description <code>sensor_array</code> <code>list(WindSensor)</code> <p>List of all WindSensor input files managed by the WindSensorArray.</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensorArray.wind_times","title":"wind_times  <code>property</code>","text":"<pre><code>wind_times: list\n</code></pre> <p>Creates a global wind times list by combining the wind times lists of each sensor.</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensorArray.validate_unique_sensor_names","title":"validate_unique_sensor_names","text":"<pre><code>validate_unique_sensor_names()\n</code></pre> <p>Validate that all sensor names are unique.</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensorArray.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(directory: str | Path)\n</code></pre> <p>Initializes a WindSensorArray object from a directory by reading sensor names and files from QU_metparams.inp.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Directory containing the QU_metparams.inp and sensor files</p> required <p>Returns:</p> Type Description <code>WindSensorArray</code> <p>Initialized WindSensorArray object containing all wind sensors</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If QU_metparams.inp or any sensor file is not found</p> <code>ValueError</code> <p>If there is an error parsing the sensor files</p>"},{"location":"reference/#quicfire_tools.inputs.WindSensorArray.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the object to a dictionary, excluding attributes that start with an underscore.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object.</p>"},{"location":"reference/#quicfire_tools.ignitions","title":"quicfire_tools.ignitions","text":"<p>QUIC-Fire Tools Ignitions Module</p>"},{"location":"reference/#quicfire_tools.ignitions.IgnitionFlags","title":"IgnitionFlags","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Enum class for all valid ignition source options in QUIC-Fire.</p>"},{"location":"reference/#quicfire_tools.ignitions.Ignition","title":"Ignition","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all ignition types in QUIC-Fire. This class is used to provide a common string representation for all ignition types.</p>"},{"location":"reference/#quicfire_tools.ignitions.RectangleIgnition","title":"RectangleIgnition","text":"<p>               Bases: <code>Ignition</code></p> <p>Represents a rectangle ignition source in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>x_min</code> <code>float</code> <p>South-west corner in the x-direction [m]</p> <code>y_min</code> <code>float</code> <p>South-west corner in the y-direction [m]</p> <code>x_length</code> <code>float</code> <p>Length in the x-direction [m]</p> <code>y_length</code> <code>float</code> <p>Length in the y-direction [m]</p>"},{"location":"reference/#quicfire_tools.ignitions.SquareRingIgnition","title":"SquareRingIgnition","text":"<p>               Bases: <code>Ignition</code></p> <p>Represents a square ring ignition source in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>x_min</code> <code>float</code> <p>South-west corner in the x-direction [m]</p> <code>y_min</code> <code>float</code> <p>South-west corner in the y-direction [m]</p> <code>x_length</code> <code>float</code> <p>Length in the x-direction [m]</p> <code>y_length</code> <code>float</code> <p>Length in the y-direction [m]</p> <code>x_width</code> <code>float</code> <p>Width in the x-direction [m]</p> <code>y_width</code> <code>float</code> <p>Width in the y-direction [m]</p>"},{"location":"reference/#quicfire_tools.ignitions.CircularRingIgnition","title":"CircularRingIgnition","text":"<p>               Bases: <code>Ignition</code></p> <p>Represents a circular ring ignition source in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>x_min</code> <code>float</code> <p>South-west corner in the x-direction [m]</p> <code>y_min</code> <code>float</code> <p>South-west corner in the y-direction [m]</p> <code>x_length</code> <code>float</code> <p>Length in the x-direction [m]</p> <code>y_length</code> <code>float</code> <p>Length in the y-direction [m]</p> <code>ring_width</code> <code>float</code> <p>Width of the ring [m]</p>"},{"location":"reference/#quicfire_tools.topography","title":"quicfire_tools.topography","text":"<p>QUIC-Fire Tools Topography Model</p>"},{"location":"reference/#quicfire_tools.topography.TopoFlags","title":"TopoFlags","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Enum class for all valid topography source options in QUIC-Fire.</p>"},{"location":"reference/#quicfire_tools.topography.Topography","title":"Topography","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all topography types in QUIC-Fire. This class is used to provide a common string representation for all topography types.</p>"},{"location":"reference/#quicfire_tools.topography.GaussianHillTopo","title":"GaussianHillTopo","text":"<p>               Bases: <code>Topography</code></p> <p>Creates a Gaussian hill topography in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>x_hilltop</code> <code>PositiveFloat</code> <p>Gaussian hill top location x-direction [m]</p> <code>y_hilltop</code> <code>PositiveFloat</code> <p>Gaussian hill top location y-direction [m]</p> <code>elevation_max</code> <code>PositiveFloat</code> <p>Maximum elevation of the Gaussian hill [m]</p> <code>elevation_std</code> <code>PositiveFloat</code> <p>Standard deviation of the Gaussian hill [m]</p>"},{"location":"reference/#quicfire_tools.topography.HillPassTopo","title":"HillPassTopo","text":"<p>               Bases: <code>Topography</code></p> <p>Creates a hill pass topography in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>max_height</code> <code>PositiveFloat</code> <p>Maximum elevation of the hill pass [m]</p> <code>location_param</code> <code>PositiveFloat</code> <p>Location parameter of the hill pass [m]</p>"},{"location":"reference/#quicfire_tools.topography.SlopeMesaTopo","title":"SlopeMesaTopo","text":"<p>               Bases: <code>Topography</code></p> <p>Creates a slope mesa topography in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>slope_axis</code> <code>Literal[0, 1]</code> <p>Slope axis (0 = x, 1 = y)</p> <code>slope_value</code> <code>float</code> <p>Slope in dh/dx or dh/dy</p>"},{"location":"reference/#quicfire_tools.topography.CanyonTopo","title":"CanyonTopo","text":"<p>               Bases: <code>Topography</code></p> <p>Creates a canyon topography in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>x_location</code> <code>PositiveFloat</code> <p>Canyon location in x-dir [m].</p> <code>y_location</code> <code>PositiveFloat</code> <p>Canyon location in y-dir [m].</p> <code>slope_value</code> <code>PositiveFloat</code> <p>Slope in dh/dx or dy/dy [-].</p> <code>canyon_std</code> <code>PositiveFloat</code> <p>Canyon function standard deviation [m].</p> <code>vertical_offset</code> <code>PositiveFloat</code> <p>Canyon vertical offset [m].</p>"},{"location":"reference/#quicfire_tools.topography.HalfCircleTopo","title":"HalfCircleTopo","text":"<p>               Bases: <code>Topography</code></p> <p>Creates a half-circle topography in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>x_location</code> <code>PositiveFloat</code> <p>The x-coordinate of the center of the half-circle topography [m].</p> <code>y_location</code> <code>PositiveFloat</code> <p>The y-coordinate of the center of the half-circle topography [m].</p> <code>radius</code> <code>PositiveFloat</code> <p>The radius of the half-circle topography [m].</p>"},{"location":"reference/#quicfire_tools.topography.SinusoidTopo","title":"SinusoidTopo","text":"<p>               Bases: <code>Topography</code></p> <p>Creates a sinusoidal topography in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>period</code> <code>PositiveFloat</code> <p>The period of the sinusoidal wave [m].</p> <code>amplitude</code> <code>PositiveFloat</code> <p>The amplitude of the sinusoidal wave [m].</p>"},{"location":"reference/#quicfire_tools.topography.CosHillTopo","title":"CosHillTopo","text":"<p>               Bases: <code>Topography</code></p> <p>Creates a cosine-shaped hill topography in QUIC-Fire.</p> <p>Attributes:</p> Name Type Description <code>aspect</code> <code>PositiveFloat</code> <p>The aspect (or orientation) of the hill [-].</p> <code>height</code> <code>PositiveFloat</code> <p>The height of the hill [m].</p>"},{"location":"reference/#quicfire_tools.outputs","title":"quicfire_tools.outputs","text":"<p>Module for converting QUIC-Fire output files to duck array data formats.</p>"},{"location":"reference/#quicfire_tools.outputs.OutputFile","title":"OutputFile","text":"<p>A class representing a single output file. This class provides a common interface for processing and retrieving data from output files.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the output file this object represents.</p> <code>file_format</code> <code>str</code> <p>The format of the output file. Valid options are \"gridded\" and \"compressed\".</p> <code>dimensions</code> <code>list[str]</code> <p>The dimensions of the output file as [\"z\", \"y\", \"x\"] or [\"y\", \"x\"].</p> <code>shape</code> <code>tuple</code> <p>The shape of the output file array data as (nz, ny, nx).</p> <code>grid</code> <code>str</code> <p>The grid type of the output file. Valid options are \"fire\" and \"quic\".</p> <code>x_coords</code> <code>list[float]</code> <p>The x coordinates of the output file. Coordinates are in the UTM coordinate system with the origin at the southwest corner of the domain.</p> <code>y_coords</code> <code>list[float]</code> <p>The y coordinates of the output file. Coordinates are in the UTM coordinate system with the origin at the southwest corner of the domain.</p> <code>z_coords</code> <code>list[float]</code> <p>The z coordinates of the output file. Coordinates are in meters above the ground level.</p> <code>delimiter</code> <code>str</code> <p>The delimiter used in the output file name.</p> <code>extension</code> <code>str</code> <p>The file extension of the output file.</p> <code>description</code> <code>str</code> <p>A description of the output file.</p> <code>units</code> <code>str</code> <p>The units of the output file.</p> <code>filepaths</code> <code>list[Path]</code> <p>A list of file paths for each timestep.</p> <code>times</code> <code>list[int]</code> <p>A list of times corresponding to the timesteps.</p>"},{"location":"reference/#quicfire_tools.outputs.OutputFile.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy(\n    timestep: int | list[int] | range = None,\n) -&gt; np.ndarray\n</code></pre> <p>Return a numpy array for the given output and timestep(s) with shape (time, nz, ny, nx). If timestep is None, then all timesteps are returned.</p> <p>Parameters:</p> Name Type Description Default <code>timestep</code> <code>int | list[int] | range</code> <p>The timestep(s) to return. If None, then all timesteps are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 4D numpy array with shape (time, nz, ny, nx) containing the output data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; outputs = qft.SimulationOutputs(\"path/to/outputs\", 50, 100, 100)\n&gt;&gt;&gt; fire_energy = outputs.get_output(\"fire-energy_to_atmos\")\n&gt;&gt;&gt; # Get all timesteps for the fire-energy_to_atmos output\n&gt;&gt;&gt; fire_energy_all = fire_energy.to_numpy()\n&gt;&gt;&gt; # Get the first timestep for the fire-energy_to_atmos output\n&gt;&gt;&gt; fire_energy_slice = fire_energy.to_numpy(timestep=0)\n</code></pre>"},{"location":"reference/#quicfire_tools.outputs.OutputFile.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(\n    directory: str | Path, timestep: int | list[int] = None\n)\n</code></pre> <p>Write a netCDF file for the given output and timestep(s) with dimensions (time, nz, ny, nx). If timestep is None, then all timesteps are returned.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The path to the folder where netCDF file will be written.</p> required <code>timestep</code> <code>int | list[int]</code> <p>The timestep(s) to write. If None, then all timesteps are written.</p> <code>None</code> Builds <p>netCDF file to disk</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; outputs = qft.SimulationOutputs(\"path/to/outputs\", 50, 100, 100)\n&gt;&gt;&gt; fire_energy = outputs.get_output(\"fire-energy_to_atmos\")\n&gt;&gt;&gt; out_dir = Path(path/to/output/dir)\n&gt;&gt;&gt; # Get all timesteps for the fire-energy_to_atmos output\n&gt;&gt;&gt; fire_energy_all = fire_energy.to_netcdf(directory = out_dir)\n&gt;&gt;&gt; # Get the first timestep for the fire-energy_to_atmos output\n&gt;&gt;&gt; fire_energy_slice = fire_energy.to_netcdf(directory = out_dir, timestep=0)\n</code></pre>"},{"location":"reference/#quicfire_tools.outputs.OutputFile.to_zarr","title":"to_zarr","text":"<pre><code>to_zarr(\n    fpath: str | Path,\n    chunk_size: dict[str, int] = None,\n    **kwargs\n) -&gt; zarr.Group\n</code></pre> <p>Write the outputs to a zarr file.</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str | Path</code> <p>The path to the folder where zarr files are written to be written.</p> required <code>chunk_size</code> <code>dict[str, int]</code> <p>The chunk size for the zarr array. The dictionary may contain keys \"time\", \"z\", \"y\", and \"x\" with integer values for the chunk size in each dimension. The default chunk size is (1, nz, ny, nx). If a key is not present, then the chunk size defaults to the size of the dimension.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the zarr array creation function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Group</code> <p>The zarr group containing the output data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; outputs = qft.SimulationOutputs(\"path/to/outputs\", 50, 100, 100)\n&gt;&gt;&gt; fire_energy = outputs.get_output(\"fire-energy_to_atmos\")\n&gt;&gt;&gt; # Write fire-energy_to_atmos output to zarr\n&gt;&gt;&gt; zarr_group = fire_energy.to_zarr(\"path/to/zarr\")\n&gt;&gt;&gt; zarr_group[\"fuels-dens\"]\n&lt;zarr.core.Array '/fuels-dens' (2, 1, 200, 200) float64 read-only&gt;\n&gt;&gt;&gt; # Write multiple timesteps to each zarr chunk to improve I/O\n&gt;&gt;&gt; zarr_group = fire_energy.to_zarr(\"path/to/zarr\", chunk_size={\"time\": 100})\n&gt;&gt;&gt; zarr_group[\"fuels-dens\"].chunks\n(100, 1, 200, 200)\n</code></pre>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs","title":"SimulationOutputs","text":"<p>A class responsible for managing and processing simulation outputs, including validation, extraction, and organization of data from output files. This class facilitates the retrieval of data in various formats and can return a numpy array for a specific output, or write the data to a zarr file.</p> <p>Attributes:</p> Name Type Description <code>output_directory</code> <code>Path</code> <p>The path to the directory containing the simulation outputs. QUIC-Fire defaults this to the \"Output\" directory in the same directory as the simulation input files, but that does not have to be the case for quicfire-tools. The directory must contain the \"fire_indexes.bin\" and \"grid.bin\" files.</p> <code>fire_nz</code> <code>int</code> <p>The number of vertical cells in the fire grid.</p> <code>ny</code> <code>int</code> <p>The number of cells in the y-direction.</p> <code>nx</code> <code>int</code> <p>The number of cells in the x-direction.</p> <code>dy</code> <code>float</code> <p>The grid spacing in the y-direction (m). Defaults to 2m.</p> <code>dx</code> <code>float</code> <p>The grid spacing in the x-direction (m). Defaults to 2m.</p> <code>utm_x</code> <code>float</code> <p>UTM-x coordinates of the south-west corner of domain [m]. Default is 0.</p> <code>utm_y</code> <code>float</code> <p>UTM-y coordinates of the south-west corner of domain [m]. Default is 0.</p> <code>utm_zone</code> <code>int</code> <p>UTM zone of the domain. Default is None. If None, the coordinates are considered not to be georeferenced.</p> <code>crs</code> <code>str</code> <p>EPSG code for the coordinate reference system. If the UTM zone is provided, the crs is set to the UTM zone. If the UTM zone is not provided, the crs is set to None.</p>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Return an iterator for the object.</p>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs.__next__","title":"__next__","text":"<pre><code>__next__()\n</code></pre> <p>Return the next item in the iterator.</p>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs.from_simulation_inputs","title":"from_simulation_inputs  <code>classmethod</code>","text":"<pre><code>from_simulation_inputs(\n    output_directory: Path | str,\n    simulation_inputs: SimulationInputs,\n) -&gt; SimulationOutputs\n</code></pre> <p>Create a SimulationOutputs object from a path to a QUIC-Fire \"Output\" directory and a SimulationInputs object.</p> <p>Parameters:</p> Name Type Description Default <code>output_directory</code> <code>Path | str</code> <p>The path to the directory containing the simulation outputs. The directory must contain the \"fire_indexes.bin\" and \"grid.bin\" files. This is typically the \"Output\" directory in the same directory as the simulation input files, but that does not have to be the case for quicfire-tools.</p> required <code>simulation_inputs</code> <code>SimulationInputs</code> <p>The SimulationInputs object containing the simulation input data.</p> required <p>Returns:</p> Type Description <code>SimulationOutputs</code> <p>A SimulationOutputs object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; inputs = qft.SimulationInputs.from_directory(\"path/to/inputs\")\n&gt;&gt;&gt; outputs = qft.SimulationOutputs.from_simulation_inputs(\"path/to/outputs\", inputs)\n</code></pre>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs.list_outputs","title":"list_outputs","text":"<pre><code>list_outputs() -&gt; list[str]\n</code></pre> <p>Return a list of available output names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of available output names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; outputs = qft.SimulationOutputs(\"path/to/outputs\")\n&gt;&gt;&gt; outputs.list_outputs()\n['fire-energy_to_atmos', 'fuels-dens', 'groundfuelheight', 'mburnt_integ']\n</code></pre>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs.get_output","title":"get_output","text":"<pre><code>get_output(key) -&gt; OutputFile\n</code></pre> <p>Return the OutputFile object for the given output name.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>The name of the output to return.</p> required <p>Returns:</p> Type Description <code>OutputFile</code> <p>The OutputFile object for the given output name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the output name is not valid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; outputs = qft.SimulationOutputs(\"path/to/outputs\")\n&gt;&gt;&gt; fire_energy = outputs.get_output(\"fire-energy_to_atmos\")\n&gt;&gt;&gt; fire_energy\n&lt;quicfire_tools.outputs.OutputFile object at 0x7f8b1c2b6d90&gt;\n</code></pre>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy(\n    key: str,\n    timestep: None | int | list[int] | range = None,\n) -&gt; np.ndarray\n</code></pre> <p>Returns a 4D numpy array for the given output and timestep(s) with shape (time, nz, ny, nx). If timestep is None, then all timesteps are returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the output to return.</p> required <code>timestep</code> <code>None | int | list[int] | range</code> <p>The timestep(s) to return. If None, then all timesteps are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 4D numpy array with shape (time, nz, ny, nx) containing the output data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; outputs = qft.SimulationOutputs(\"path/to/outputs\", 50, 100, 100)\n&gt;&gt;&gt; output_name = \"fire-energy_to_atmos\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get all timesteps for the fire-energy_to_atmos output\n&gt;&gt;&gt; fire_energy_all = outputs.to_numpy(output_name)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get the first timestep for the fire-energy_to_atmos output\n&gt;&gt;&gt; fire_energy_first_time_step = outputs.to_numpy(output_name, timestep=0)\n</code></pre>"},{"location":"reference/#quicfire_tools.outputs.SimulationOutputs.to_dask","title":"to_dask","text":"<pre><code>to_dask(key: str) -&gt; da.Array\n</code></pre> <p>Returns a dask array for the given output with shape (time, nz, ny, nx).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the output to return.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A dask array with shape (time, nz, ny, nx) containing the output data with chunks of size (1, nz, ny, nx). The dask array is lazily evaluated, so users must call <code>.compute()</code> to retrieve the data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import quicfire_tools as qft\n&gt;&gt;&gt; outputs = qft.SimulationOutputs(\"path/to/outputs\", 50, 100, 100)\n&gt;&gt;&gt; fire_energy_da = outputs.to_dask(\"fire-energy_to_atmos\")\n&gt;&gt;&gt; fire_energy_np = fire_energy_da.compute()  # Retrieve the data\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#creating-a-quic-fire-simulation-with-quicfire-tools","title":"Creating a QUIC-Fire Simulation with quicfire-tools.","text":"<p>Welcome to the tutorial on how to create a QUIC-Fire simulation using quicfire-tools, a Python package designed to streamline the process of managing QUIC-Fire input file decks and processing output files. This tutorial will take you through the necessary steps to set up a basic QUIC-Fire simulation, focusing on using the SimulationInputs class from the inputs module.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting this tutorial, ensure that you have:</p> <ul> <li>Python 3.8 or higher installed on your system.</li> <li>The quicfire-tools package installed on your system. If you do not have quicfire-tools installed, please see the   installation instructions in the documentation.</li> </ul>"},{"location":"tutorials/#step-1-import-the-simulationinputs-class","title":"Step 1: Import the SimulationInputs class","text":"<p>Start by importing the SimulationInputs class from the quicfire_tools.inputs module:</p> <pre><code>from quicfire_tools.inputs import SimulationInputs\n</code></pre>"},{"location":"tutorials/#step-2-creating-a-uniform-line-fire-simulation","title":"Step 2: Creating a Uniform Line Fire Simulation","text":"<p>In this step, we will create a function to set up a basic QUIC-Fire simulation. This involves initializing the simulation, defining fuel characteristics, setting the ignition area, and specifying output files.</p>"},{"location":"tutorials/#step-21-initialize-the-simulation","title":"Step 2.1: Initialize the simulation","text":"<p>First, we initialize the simulation with the grid size, simulation time, and wind conditions. The <code>create_simulation</code> method of <code>SimulationInputs</code> is used for this purpose.</p> <pre><code>simulation = SimulationInputs.create_simulation(\n    nx=200,\n    ny=200,\n    fire_nz=1,\n    wind_speed=1.7,\n    wind_direction=90,\n    simulation_time=600\n)\n</code></pre> <ul> <li>nx and ny define the number of cells in the x and y axis of the simulation grid.</li> <li>fire_nz determines the number of cells in the z-axis for the fire grid.</li> <li>wind_speed and wind_direction set the initial wind conditions.</li> <li>simulation_time specifies how long the simulation will run in seconds.</li> </ul>"},{"location":"tutorials/#step-22-define-uniform-fuel-characteristics","title":"Step 2.2: Define Uniform Fuel Characteristics","text":"<p>Next, we define the characteristics of the fuel. The <code>set_uniform_fuels</code> method sets the fuel density, moisture, and height uniformly across the simulation grid.</p> <pre><code>simulation.set_uniform_fuels(\n    fuel_density=0.7,\n    fuel_moisture=0.10,\n    fuel_height=1.0\n)\n</code></pre> <ul> <li>fuel_density sets the surface fuel density in kg/m^3.</li> <li>fuel_moisture sets the surface fuel moisture content as a fraction of the fuel's dry weight.</li> <li>fuel_height sets the surface fuel height in meters.</li> </ul>"},{"location":"tutorials/#step-23-set-the-ignition-area","title":"Step 2.3: Set the Ignition Area","text":"<p>Now, we specify the area where the fire will start. The <code>set_rectangle_ignition</code> method is used to create a rectangular ignition zone simulating a line fire ignition pattern.</p> <pre><code>simulation.set_rectangle_ignition(\n    x_min=150,\n    y_min=100,\n    x_length=10,\n    y_length=100\n)\n</code></pre> <ul> <li>x_min and y_min set the coordinates of the bottom left corner of the ignition zone. These coordinates are specified in meters, not grid cells.</li> <li>x_length and y_length set the length of the ignition zone in the x and y directions in meters.</li> </ul>"},{"location":"tutorials/#step-24-specify-output-files","title":"Step 2.4: Specify Output Files","text":"<p>Finally, we specify the types of output files the simulation will generate. The <code>set_output_files</code> method allows you to choose which data to output.</p> <pre><code>simulation.set_output_files(\n    fuel_dens=True,\n    emissions=True,\n    qu_wind_inst=True\n)\n</code></pre> <p>In this example: - fuel_dens specifies a compressed array fuel density output. - emissions specifies CO, PM2.5, and water emissions outputs. - qu_wind_inst specifies gridded wind components (u, v, w) for the QUIC (wind) grid.</p>"},{"location":"tutorials/#step-3-write-the-simulation-to-a-directory","title":"Step 3: Write the Simulation to a Directory","text":"<p>Now that we have created the simulation, we can write it to a directory containing a QUIC-Fire executable to run the fire model. The <code>write_simulation</code> method of is used for this purpose.</p> <pre><code>simulation.write_inputs(\"path/to/directory\")\n</code></pre>"},{"location":"tutorials/#finished-code","title":"Finished Code","text":"<p>The following code block combines all the steps in this tutorial to create a basic QUIC-Fire simulation using quicfire-tools.</p> <pre><code>from quicfire_tools.inputs import SimulationInputs\n\nsimulation = SimulationInputs.create_simulation(\n    nx=200,\n    ny=200,\n    fire_nz=1,\n    wind_speed=1.7,\n    wind_direction=90,\n    simulation_time=600\n)\n\nsimulation.set_uniform_fuels(\n    fuel_density=0.7,\n    fuel_moisture=0.10,\n    fuel_height=1.0\n)\n\nsimulation.set_rectangle_ignition(\n    x_min=150,\n    y_min=100,\n    x_length=10,\n    y_length=100\n)\n\nsimulation.set_output_files(\n    fuel_dens=True,\n    emissions=True,\n    qu_wind_inst=True\n)\n\nsimulation.write_inputs(\"path/to/directory\")\n</code></pre>"},{"location":"tutorials/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have learned how to create a basic QUIC-Fire simulation using the SimulationInputs class from the inputs module. We have also learned how to write the simulation to a directory containing a QUIC-Fire executable to run the fire model.</p> <p>quicfire-tools is designed to set up simulations in a quick, easy, and repeatable manner. The scope of the inputs module ends at writing the simulation to a directory. Running a simulation and understanding the relevant inputs are the responsibility of the user.</p> <p>For more information about setting up a QUIC-Fire simulation, please see the How-to-Guide for more examples of working with the inputs module, and the Reference page for a complete list of available methods and attributes.</p>"},{"location":"tutorials/#reading-quic-fire-output-files-with-quicfire-tools","title":"Reading QUIC-Fire Output Files with quicfire-tools.","text":"<p>In this tutorial, we will learn how to read QUIC-Fire output files using quicfire-tools, a Python package designed to streamline the process of managing QUIC-Fire input file decks and processing output files. This tutorial will take you through the necessary steps to read a QUIC-Fire output file into a numpy array, focusing on using the OutputFile class from the outputs module.</p>"},{"location":"tutorials/#prerequisites_1","title":"Prerequisites","text":"<p>Before starting this tutorial, ensure that you have:</p> <ul> <li>Python 3.8 or higher installed on your system.</li> <li>The quicfire-tools package installed on your system. If you do not have quicfire-tools installed, please see the   installation instructions in the documentation.</li> <li>An Outputs directory containing the output files from a QUIC-Fire simulation. quicfire-tools does not handle running   QUIC-Fire simulations and it is the responsibility of the user to run the fire model and understand the relevant   inputs.</li> </ul>"},{"location":"tutorials/#step-1-import-the-necessary-modules","title":"Step 1: Import the necessary modules","text":"<p>Start by importing the SimulationInputs class from the quicfire_tools.outputs module:</p> <pre><code>from quicfire_tools.outputs import SimulationOutputs\n</code></pre>"},{"location":"tutorials/#step-2-create-a-simulationoutputs-object","title":"Step 2: Create a SimulationOutputs object","text":"<p>Next, create a SimulationOutputs object. The SimulationOutputs class is used to read and process QUIC-Fire outputs. You can create a SimulationOutputs object by passing the path to the Outputs directory containing the output files to the constructor.</p> <p>In addition to the path to the Outputs directory, you also need to specify the number of cells in the z, y, and x directions of the simulation grid. This information is used to reshape the output files into a 3D numpy array.</p> <pre><code>output_directory = \"/path/to/output/directory\"\nnz = 56  # number of z cells\nny = 100  # number of y cells\nnx = 100  # number of x cells\n\nsimulation_outputs = SimulationOutputs(output_directory, nz, ny, nx)\n</code></pre>"},{"location":"tutorials/#step-3-get-an-output-file","title":"Step 3: Get an Output File","text":"<p>You can use the SimulationOutputs object to get the <code>OutputFile</code> object for the output that you want to read data from. To do this, use the <code>get_output_file</code> method of the SimulationOutputs class.</p> <pre><code>output_name = \"fire-energy_to_atmos\"  # replace with the name of the output you are interested in\noutput_file = simulation_outputs.get_output(output_name)\n</code></pre>"},{"location":"tutorials/#step-4-get-the-output-data-as-a-numpy-array","title":"Step 4: Get the output data as a numpy array","text":"<p>Finally, you can get a numpy array for the output data using the <code>to_numpy</code> method of the <code>OutputFile</code> instance. You can specify the timestep(s) you are interested in. If you don't provide a timestep, all timesteps will be returned:</p> <pre><code>timestep = 0  # replace with the timestep you are interested in\noutput_data = output_file.to_numpy(timestep)\n</code></pre>"},{"location":"tutorials/#finished-code_1","title":"Finished Code","text":"<p>The following code block combines all the steps in this tutorial to read a QUIC-Fire output file into a numpy array using quicfire-tools.</p> <pre><code>from quicfire_tools.outputs import SimulationOutputs\n\noutput_directory = \"/path/to/output/directory\"\nnz = 56  # number of z cells\nny = 100  # number of y cells\nnx = 100  # number of x cells\n\nsimulation_outputs = SimulationOutputs(output_directory, nz, ny, nx)\n\noutput_name = \"fire-energy_to_atmos\"  # replace with the name of the output you are interested in\noutput_file = simulation_outputs.get_output(output_name)\n\ntimestep = 0  # replace with the timestep you are interested in\noutput_data = output_file.to_numpy(timestep)\n</code></pre>"}]}